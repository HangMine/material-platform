/* eslint-disable */
// @ts-nocheck

(() => {
  'use strict';

  var __webpack_modules__ = {
    362: (__unused_webpack_module, exports, __nccwpck_require__) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.Binary = void 0; let buffer_1 = __nccwpck_require__(293); let ensure_buffer_1 = __nccwpck_require__(404); let uuid_utils_1 = __nccwpck_require__(577); let uuid_1 = __nccwpck_require__(809); let Binary = (function () { function Binary(buffer, subType) { if (!(this instanceof Binary)) return new Binary(buffer, subType); if (!(buffer == null) && !(typeof buffer === "string") && !ArrayBuffer.isView(buffer) && !(buffer instanceof ArrayBuffer) && !Array.isArray(buffer)) { throw new TypeError('Binary can only be constructed from string, Buffer, TypedArray, or Array<number>') } this.sub_type = subType !== null && subType !== void 0 ? subType : Binary.BSON_BINARY_SUBTYPE_DEFAULT; if (buffer == null) { this.buffer = buffer_1.Buffer.alloc(Binary.BUFFER_SIZE); this.position = 0 } else { if (typeof buffer === "string") { this.buffer = buffer_1.Buffer.from(buffer, "binary") } else if (Array.isArray(buffer)) { this.buffer = buffer_1.Buffer.from(buffer) } else { this.buffer = ensure_buffer_1.ensureBuffer(buffer) } this.position = this.buffer.byteLength } } Binary.prototype.put = function (byteValue) { if (typeof byteValue === "string" && byteValue.length !== 1) { throw new TypeError('only accepts single character String') } else if (typeof byteValue !== "number" && byteValue.length !== 1) throw new TypeError('only accepts single character Uint8Array or Array'); var decodedByte; if (typeof byteValue === "string") { decodedByte = byteValue.charCodeAt(0) } else if (typeof byteValue === "number") { decodedByte = byteValue } else { decodedByte = byteValue[0] } if (decodedByte < 0 || decodedByte > 255) { throw new TypeError('only accepts number in a valid unsigned byte range 0-255') } if (this.buffer.length > this.position) { this.buffer[this.position++] = decodedByte } else { var buffer = buffer_1.Buffer.alloc(Binary.BUFFER_SIZE + this.buffer.length); this.buffer.copy(buffer, 0, 0, this.buffer.length); this.buffer = buffer; this.buffer[this.position++] = decodedByte } }; Binary.prototype.write = function (sequence, offset) { offset = typeof offset === "number" ? offset : this.position; if (this.buffer.length < offset + sequence.length) { var buffer = buffer_1.Buffer.alloc(this.buffer.length + sequence.length); this.buffer.copy(buffer, 0, 0, this.buffer.length); this.buffer = buffer } if (ArrayBuffer.isView(sequence)) { this.buffer.set(ensure_buffer_1.ensureBuffer(sequence), offset); this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position } else if (typeof sequence === "string") { this.buffer.write(sequence, offset, sequence.length, "binary"); this.position = offset + sequence.length > this.position ? offset + sequence.length : this.position } }; Binary.prototype.read = function (position, length) { length = length && length > 0 ? length : this.position; return this.buffer.slice(position, position + length) }; Binary.prototype.value = function (asRaw) { asRaw = !!asRaw; if (asRaw && this.buffer.length === this.position) { return this.buffer } if (asRaw) { return this.buffer.slice(0, this.position) } return this.buffer.toString('binary', 0, this.position) }; Binary.prototype.length = function () { return this.position }; Binary.prototype.toJSON = function () { return this.buffer.toString('base64') }; Binary.prototype.toString = function (format) { return this.buffer.toString(format) }; Binary.prototype.toExtendedJSON = function (options) { options = options || {}; var base64String = this.buffer.toString('base64'); var subType = Number(this.sub_type).toString(16); if (options.legacy) { return { $binary: base64String, $type: subType.length === 1 ? "0" + subType : subType } } return { $binary: { base64: base64String, subType: subType.length === 1 ? "0" + subType : subType } } }; Binary.prototype.toUUID = function () { if (this.sub_type === Binary.SUBTYPE_UUID) { return new uuid_1.UUID(this.buffer.slice(0, this.position)) } throw new Error(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${Binary.SUBTYPE_UUID}" is currently supported.`) }; Binary.fromExtendedJSON = function (doc, options) { options = options || {}; var data; var type; if ('$binary' in doc) { if (options.legacy && typeof doc.$binary === "string" && "$type" in doc) { type = doc.$type ? parseInt(doc.$type, 16) : 0; data = buffer_1.Buffer.from(doc.$binary, "base64") } else { if (typeof doc.$binary !== "string") { type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0; data = buffer_1.Buffer.from(doc.$binary.base64, "base64") } } } else if ('$uuid' in doc) { type = 4; data = uuid_utils_1.uuidHexStringToBuffer(doc.$uuid) } if (!data) { throw new TypeError('Unexpected Binary Extended JSON format ' + JSON.stringify(doc)) } return new Binary(data, type) }; Binary.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return this.inspect() }; Binary.prototype.inspect = function () { var asBuffer = this.value(true); return 'new Binary(Buffer.from("' + asBuffer.toString('hex') + '", "hex"), ' + this.sub_type + ")" }; Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0; Binary.BUFFER_SIZE = 256; Binary.SUBTYPE_DEFAULT = 0; Binary.SUBTYPE_FUNCTION = 1; Binary.SUBTYPE_BYTE_ARRAY = 2; Binary.SUBTYPE_UUID_OLD = 3; Binary.SUBTYPE_UUID = 4; Binary.SUBTYPE_MD5 = 5; Binary.SUBTYPE_USER_DEFINED = 128; return Binary }()); exports.Binary = Binary; Object.defineProperty(Binary.prototype, '_bsontype', { value: 'Binary' }); }, 974: (__unused_webpack_module, exports) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.Code = void 0; let Code = (function () { function Code(code, scope) { if (!(this instanceof Code)) return new Code(code, scope); this.code = code; this.scope = scope } Code.prototype.toJSON = function () { return { code: this.code, scope: this.scope } }; Code.prototype.toExtendedJSON = function () { if (this.scope) { return { $code: this.code, $scope: this.scope } } return { $code: this.code } }; Code.fromExtendedJSON = function (doc) { return new Code(doc.$code, doc.$scope) }; Code.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return this.inspect() }; Code.prototype.inspect = function () { var codeJson = this.toJSON(); return 'new Code("' + codeJson.code + '"' + (codeJson.scope ? ", " + JSON.stringify(codeJson.scope) : '') + ")" }; return Code }()); exports.Code = Code; Object.defineProperty(Code.prototype, '_bsontype', { value: 'Code' }); }, 550: (__unused_webpack_module, exports) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.BSON_BINARY_SUBTYPE_USER_DEFINED = exports.BSON_BINARY_SUBTYPE_MD5 = exports.BSON_BINARY_SUBTYPE_UUID_NEW = exports.BSON_BINARY_SUBTYPE_UUID = exports.BSON_BINARY_SUBTYPE_BYTE_ARRAY = exports.BSON_BINARY_SUBTYPE_FUNCTION = exports.BSON_BINARY_SUBTYPE_DEFAULT = exports.BSON_DATA_MAX_KEY = exports.BSON_DATA_MIN_KEY = exports.BSON_DATA_DECIMAL128 = exports.BSON_DATA_LONG = exports.BSON_DATA_TIMESTAMP = exports.BSON_DATA_INT = exports.BSON_DATA_CODE_W_SCOPE = exports.BSON_DATA_SYMBOL = exports.BSON_DATA_CODE = exports.BSON_DATA_DBPOINTER = exports.BSON_DATA_REGEXP = exports.BSON_DATA_NULL = exports.BSON_DATA_DATE = exports.BSON_DATA_BOOLEAN = exports.BSON_DATA_OID = exports.BSON_DATA_UNDEFINED = exports.BSON_DATA_BINARY = exports.BSON_DATA_ARRAY = exports.BSON_DATA_OBJECT = exports.BSON_DATA_STRING = exports.BSON_DATA_NUMBER = exports.JS_INT_MIN = exports.JS_INT_MAX = exports.BSON_INT64_MIN = exports.BSON_INT64_MAX = exports.BSON_INT32_MIN = exports.BSON_INT32_MAX = void 0; exports.BSON_INT32_MAX = 2147483647; exports.BSON_INT32_MIN = -2147483648; exports.BSON_INT64_MAX = Math.pow(2, 63) - 1; exports.BSON_INT64_MIN = -Math.pow(2, 63); exports.JS_INT_MAX = Math.pow(2, 53); exports.JS_INT_MIN = -Math.pow(2, 53); exports.BSON_DATA_NUMBER = 1; exports.BSON_DATA_STRING = 2; exports.BSON_DATA_OBJECT = 3; exports.BSON_DATA_ARRAY = 4; exports.BSON_DATA_BINARY = 5; exports.BSON_DATA_UNDEFINED = 6; exports.BSON_DATA_OID = 7; exports.BSON_DATA_BOOLEAN = 8; exports.BSON_DATA_DATE = 9; exports.BSON_DATA_NULL = 10; exports.BSON_DATA_REGEXP = 11; exports.BSON_DATA_DBPOINTER = 12; exports.BSON_DATA_CODE = 13; exports.BSON_DATA_SYMBOL = 14; exports.BSON_DATA_CODE_W_SCOPE = 15; exports.BSON_DATA_INT = 16; exports.BSON_DATA_TIMESTAMP = 17; exports.BSON_DATA_LONG = 18; exports.BSON_DATA_DECIMAL128 = 19; exports.BSON_DATA_MIN_KEY = 255; exports.BSON_DATA_MAX_KEY = 127; exports.BSON_BINARY_SUBTYPE_DEFAULT = 0; exports.BSON_BINARY_SUBTYPE_FUNCTION = 1; exports.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2; exports.BSON_BINARY_SUBTYPE_UUID = 3; exports.BSON_BINARY_SUBTYPE_UUID_NEW = 4; exports.BSON_BINARY_SUBTYPE_MD5 = 5; exports.BSON_BINARY_SUBTYPE_USER_DEFINED = 128; }, 458: (__unused_webpack_module, exports, __nccwpck_require__) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.DBRef = exports.isDBRefLike = void 0; let utils_1 = __nccwpck_require__(775); function isDBRefLike(value) { return utils_1.isObjectLike(value) && value.$id != null && value.$ref != null; } exports.isDBRefLike = isDBRefLike; let DBRef = (function () { function DBRef(collection, oid, db, fields) { if (!(this instanceof DBRef)) return new DBRef(collection, oid, db, fields); var parts = collection.split('.'); if (parts.length === 2) { db = parts.shift(); collection = parts.shift() } this.collection = collection; this.oid = oid; this.db = db; this.fields = fields || {} } Object.defineProperty(DBRef.prototype, "namespace", { get: function () { return this.collection }, set: function (value) { this.collection = value }, enumerable: false, configurable: true }); DBRef.prototype.toJSON = function () { var o = Object.assign({ $ref: this.collection, $id: this.oid }, this.fields); if (this.db != null) o.$db = this.db; return o }; DBRef.prototype.toExtendedJSON = function (options) { options = options || {}; var o = { $ref: this.collection, $id: this.oid }; if (options.legacy) { return o } if (this.db) o.$db = this.db; o = Object.assign(o, this.fields); return o }; DBRef.fromExtendedJSON = function (doc) { var copy = Object.assign({}, doc); delete copy.$ref; delete copy.$id; delete copy.$db; return new DBRef(doc.$ref, doc.$id, doc.$db, copy) }; DBRef.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return this.inspect() }; DBRef.prototype.inspect = function () { var oid = this.oid === undefined || this.oid.toString === undefined ? this.oid : this.oid.toString(); return 'new DBRef("' + this.namespace + '", new ObjectId("' + oid + '")' + (this.db ? ', "' + this.db + '"' : '') + ")" }; return DBRef }()); exports.DBRef = DBRef; Object.defineProperty(DBRef.prototype, '_bsontype', { value: 'DBRef' }); }, 407: (__unused_webpack_module, exports, __nccwpck_require__) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.Decimal128 = void 0; let buffer_1 = __nccwpck_require__(293); let long_1 = __nccwpck_require__(152); let PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/; let PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i; let PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i; let EXPONENT_MAX = 6111; let EXPONENT_MIN = -6176; let EXPONENT_BIAS = 6176; let MAX_DIGITS = 34; let NAN_BUFFER = [124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse(); let INF_NEGATIVE_BUFFER = [248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse(); let INF_POSITIVE_BUFFER = [120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse(); let EXPONENT_REGEX = /^([-+])?(\d+)?$/; let COMBINATION_MASK = 31; let EXPONENT_MASK = 16383; let COMBINATION_INFINITY = 30; let COMBINATION_NAN = 31; function isDigit(value) { return !isNaN(parseInt(value, 10)); } function divideu128(value) { let DIVISOR = long_1.Long.fromNumber(1e3 * 1e3 * 1e3); let _rem = long_1.Long.fromNumber(0); if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) { return { quotient: value, rem: _rem }; } for (let i = 0; i <= 3; i++) { _rem = _rem.shiftLeft(32); _rem = _rem.add(new long_1.Long(value.parts[i], 0)); value.parts[i] = _rem.div(DIVISOR).low; _rem = _rem.modulo(DIVISOR); } return { quotient: value, rem: _rem }; } function multiply64x2(left, right) { if (!left && !right) { return { high: long_1.Long.fromNumber(0), low: long_1.Long.fromNumber(0) }; } let leftHigh = left.shiftRightUnsigned(32); let leftLow = new long_1.Long(left.getLowBits(), 0); let rightHigh = right.shiftRightUnsigned(32); let rightLow = new long_1.Long(right.getLowBits(), 0); let productHigh = leftHigh.multiply(rightHigh); let productMid = leftHigh.multiply(rightLow); let productMid2 = leftLow.multiply(rightHigh); let productLow = leftLow.multiply(rightLow); productHigh = productHigh.add(productMid.shiftRightUnsigned(32)); productMid = new long_1.Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32)); productHigh = productHigh.add(productMid.shiftRightUnsigned(32)); productLow = productMid.shiftLeft(32).add(new long_1.Long(productLow.getLowBits(), 0)); return { high: productHigh, low: productLow }; } function lessThan(left, right) { let uhleft = left.high >>> 0; let uhright = right.high >>> 0; if (uhleft < uhright) { return true; } else if (uhleft === uhright) { let ulleft = left.low >>> 0; let ulright = right.low >>> 0; if (ulleft < ulright) return true; } return false; } function invalidErr(string, message) { throw new TypeError(`"${string}" is not a valid Decimal128 string - ${message}`); } let Decimal128 = (function () { function Decimal128(bytes) { if (!(this instanceof Decimal128)) return new Decimal128(bytes); if (typeof bytes === "string") { this.bytes = Decimal128.fromString(bytes).bytes } else { this.bytes = bytes } } Decimal128.fromString = function (representation) { var isNegative = false; var sawRadix = false; var foundNonZero = false; var significantDigits = 0; var nDigitsRead = 0; var nDigits = 0; var radixPosition = 0; var firstNonZero = 0; var digits = [0]; var nDigitsStored = 0; var digitsInsert = 0; var firstDigit = 0; var lastDigit = 0; var exponent = 0; var i = 0; var significandHigh = new long_1.Long(0, 0); var significandLow = new long_1.Long(0, 0); var biasedExponent = 0; var index = 0; if (representation.length >= 7e3) { throw new TypeError('' + representation + " not a valid Decimal128 string") } var stringMatch = representation.match(PARSE_STRING_REGEXP); var infMatch = representation.match(PARSE_INF_REGEXP); var nanMatch = representation.match(PARSE_NAN_REGEXP); if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) { throw new TypeError('' + representation + " not a valid Decimal128 string") } if (stringMatch) { var unsignedNumber = stringMatch[2]; var e = stringMatch[4]; var expSign = stringMatch[5]; var expNumber = stringMatch[6]; if (e && expNumber === undefined) invalidErr(representation, "missing exponent power"); if (e && unsignedNumber === undefined) invalidErr(representation, "missing exponent base"); if (e === undefined && (expSign || expNumber)) { invalidErr(representation, "missing e before exponent") } } if (representation[index] === "+" || representation[index] === "-") { isNegative = representation[index++] === "-" } if (!isDigit(representation[index]) && representation[index] !== ".") { if (representation[index] === "i" || representation[index] === "I") { return new Decimal128(buffer_1.Buffer.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER)) } else if (representation[index] === "N") { return new Decimal128(buffer_1.Buffer.from(NAN_BUFFER)) } } while (isDigit(representation[index]) || representation[index] === ".") { if (representation[index] === ".") { if (sawRadix) invalidErr(representation, "contains multiple periods"); sawRadix = true; index = index + 1; continue } if (nDigitsStored < 34) { if (representation[index] !== "0" || foundNonZero) { if (!foundNonZero) { firstNonZero = nDigitsRead } foundNonZero = true; digits[digitsInsert++] = parseInt(representation[index], 10); nDigitsStored = nDigitsStored + 1 } } if (foundNonZero) nDigits += 1; if (sawRadix) radixPosition += 1; nDigitsRead = nDigitsRead + 1; index = index + 1 } if (sawRadix && !nDigitsRead) throw new TypeError('' + representation + " not a valid Decimal128 string"); if (representation[index] === "e" || representation[index] === "E") { var match = representation.substr(++index).match(EXPONENT_REGEX); if (!match || !match[2]) return new Decimal128(buffer_1.Buffer.from(NAN_BUFFER)); exponent = parseInt(match[0], 10); index = index + match[0].length } if (representation[index]) return new Decimal128(buffer_1.Buffer.from(NAN_BUFFER)); firstDigit = 0; if (!nDigitsStored) { firstDigit = 0; lastDigit = 0; digits[0] = 0; nDigits = 1; nDigitsStored = 1; significantDigits = 0 } else { lastDigit = nDigitsStored - 1; significantDigits = nDigits; if (significantDigits !== 1) { while (representation[firstNonZero + significantDigits - 1] === "0") { significantDigits = significantDigits - 1 } } } if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) { exponent = EXPONENT_MIN } else { exponent = exponent - radixPosition } while (exponent > EXPONENT_MAX) { lastDigit = lastDigit + 1; if (lastDigit - firstDigit > MAX_DIGITS) { var digitsString = digits.join(''); if (digitsString.match(/^0+$/)) { exponent = EXPONENT_MAX; break } invalidErr(representation, "overflow") } exponent -= 1 } while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) { if (lastDigit === 0 && significantDigits < nDigitsStored) { exponent = EXPONENT_MIN; significantDigits = 0; break } if (nDigitsStored < nDigits) { nDigits = nDigits - 1 } else { lastDigit = lastDigit - 1 } if (exponent < EXPONENT_MAX) { exponent = exponent + 1 } else { var digitsString = digits.join(''); if (digitsString.match(/^0+$/)) { exponent = EXPONENT_MAX; break } invalidErr(representation, "overflow") } } if (lastDigit - firstDigit + 1 < significantDigits) { var endOfString = nDigitsRead; if (sawRadix) { firstNonZero = firstNonZero + 1; endOfString = endOfString + 1 } if (isNegative) { firstNonZero = firstNonZero + 1; endOfString = endOfString + 1 } var roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10); var roundBit = 0; if (roundDigit >= 5) { roundBit = 1; if (roundDigit === 5) { roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0; for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) { if (parseInt(representation[i], 10)) { roundBit = 1; break } } } } if (roundBit) { var dIdx = lastDigit; for (; dIdx >= 0; dIdx--) { if (++digits[dIdx] > 9) { digits[dIdx] = 0; if (dIdx === 0) { if (exponent < EXPONENT_MAX) { exponent = exponent + 1; digits[dIdx] = 1 } else { return new Decimal128(buffer_1.Buffer.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER)) } } } } } } significandHigh = long_1.Long.fromNumber(0); significandLow = long_1.Long.fromNumber(0); if (significantDigits === 0) { significandHigh = long_1.Long.fromNumber(0); significandLow = long_1.Long.fromNumber(0) } else if (lastDigit - firstDigit < 17) { var dIdx = firstDigit; significandLow = long_1.Long.fromNumber(digits[dIdx++]); significandHigh = new long_1.Long(0, 0); for (; dIdx <= lastDigit; dIdx++) { significandLow = significandLow.multiply(long_1.Long.fromNumber(10)); significandLow = significandLow.add(long_1.Long.fromNumber(digits[dIdx])) } } else { var dIdx = firstDigit; significandHigh = long_1.Long.fromNumber(digits[dIdx++]); for (; dIdx <= lastDigit - 17; dIdx++) { significandHigh = significandHigh.multiply(long_1.Long.fromNumber(10)); significandHigh = significandHigh.add(long_1.Long.fromNumber(digits[dIdx])) } significandLow = long_1.Long.fromNumber(digits[dIdx++]); for (; dIdx <= lastDigit; dIdx++) { significandLow = significandLow.multiply(long_1.Long.fromNumber(10)); significandLow = significandLow.add(long_1.Long.fromNumber(digits[dIdx])) } } var significand = multiply64x2(significandHigh, long_1.Long.fromString('100000000000000000')); significand.low = significand.low.add(significandLow); if (lessThan(significand.low, significandLow)) { significand.high = significand.high.add(long_1.Long.fromNumber(1)) } biasedExponent = exponent + EXPONENT_BIAS; var dec = { low: long_1.Long.fromNumber(0), high: long_1.Long.fromNumber(0) }; if (significand.high.shiftRightUnsigned(49).and(long_1.Long.fromNumber(1)).equals(long_1.Long.fromNumber(1))) { dec.high = dec.high.or(long_1.Long.fromNumber(3).shiftLeft(61)); dec.high = dec.high.or(long_1.Long.fromNumber(biasedExponent).and(long_1.Long.fromNumber(16383).shiftLeft(47))); dec.high = dec.high.or(significand.high.and(long_1.Long.fromNumber(0x7fffffffffff))) } else { dec.high = dec.high.or(long_1.Long.fromNumber(biasedExponent & 16383).shiftLeft(49)); dec.high = dec.high.or(significand.high.and(long_1.Long.fromNumber(562949953421311))) } dec.low = significand.low; if (isNegative) { dec.high = dec.high.or(long_1.Long.fromString('9223372036854775808')) } var buffer = buffer_1.Buffer.alloc(16); index = 0; buffer[index++] = dec.low.low & 255; buffer[index++] = dec.low.low >> 8 & 255; buffer[index++] = dec.low.low >> 16 & 255; buffer[index++] = dec.low.low >> 24 & 255; buffer[index++] = dec.low.high & 255; buffer[index++] = dec.low.high >> 8 & 255; buffer[index++] = dec.low.high >> 16 & 255; buffer[index++] = dec.low.high >> 24 & 255; buffer[index++] = dec.high.low & 255; buffer[index++] = dec.high.low >> 8 & 255; buffer[index++] = dec.high.low >> 16 & 255; buffer[index++] = dec.high.low >> 24 & 255; buffer[index++] = dec.high.high & 255; buffer[index++] = dec.high.high >> 8 & 255; buffer[index++] = dec.high.high >> 16 & 255; buffer[index++] = dec.high.high >> 24 & 255; return new Decimal128(buffer) }; Decimal128.prototype.toString = function () { var biased_exponent; var significand_digits = 0; var significand = new Array(36); for (var i = 0; i < significand.length; i++)significand[i] = 0; var index = 0; var is_zero = false; var significand_msb; var significand128 = { parts: [0, 0, 0, 0] }; var j; var k; var string = []; index = 0; var buffer = this.bytes; var low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; var midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; var midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; var high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; index = 0; var dec = { low: new long_1.Long(low, midl), high: new long_1.Long(midh, high) }; if (dec.high.lessThan(long_1.Long.ZERO)) { string.push('-') } var combination = high >> 26 & COMBINATION_MASK; if (combination >> 3 === 3) { if (combination === COMBINATION_INFINITY) { return `${string.join("")}Infinity` } else if (combination === COMBINATION_NAN) { return "NaN" } else { biased_exponent = high >> 15 & EXPONENT_MASK; significand_msb = 8 + (high >> 14 & 1) } } else { significand_msb = high >> 14 & 7; biased_exponent = high >> 17 & EXPONENT_MASK } var exponent = biased_exponent - EXPONENT_BIAS; significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14); significand128.parts[1] = midh; significand128.parts[2] = midl; significand128.parts[3] = low; if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) { is_zero = true } else { for (k = 3; k >= 0; k--) { var least_digits = 0; var result = divideu128(significand128); significand128 = result.quotient; least_digits = result.rem.low; if (!least_digits) continue; for (j = 8; j >= 0; j--) { significand[k * 9 + j] = least_digits % 10; least_digits = Math.floor(least_digits / 10) } } } if (is_zero) { significand_digits = 1; significand[index] = 0 } else { significand_digits = 36; while (!significand[index]) { significand_digits = significand_digits - 1; index = index + 1 } } var scientific_exponent = significand_digits - 1 + exponent; if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) { if (significand_digits > 34) { string.push('' + 0); if (exponent > 0) string.push('E+' + exponent); else if (exponent < 0) string.push('E' + exponent); return string.join('') } string.push('' + significand[index++]); significand_digits = significand_digits - 1; if (significand_digits) { string.push('.') } for (var i = 0; i < significand_digits; i++) { string.push('' + significand[index++]) } string.push('E'); if (scientific_exponent > 0) { string.push('+' + scientific_exponent) } else { string.push('' + scientific_exponent) } } else { if (exponent >= 0) { for (var i = 0; i < significand_digits; i++) { string.push('' + significand[index++]) } } else { var radix_position = significand_digits + exponent; if (radix_position > 0) { for (var i = 0; i < radix_position; i++) { string.push('' + significand[index++]) } } else { string.push('0') } string.push('.'); while (radix_position++ < 0) { string.push('0') } for (var i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) { string.push('' + significand[index++]) } } } return string.join('') }; Decimal128.prototype.toJSON = function () { return { $numberDecimal: this.toString() } }; Decimal128.prototype.toExtendedJSON = function () { return { $numberDecimal: this.toString() } }; Decimal128.fromExtendedJSON = function (doc) { return Decimal128.fromString(doc.$numberDecimal) }; Decimal128.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return this.inspect() }; Decimal128.prototype.inspect = function () { return 'new Decimal128("' + this.toString() + '")' }; return Decimal128 }()); exports.Decimal128 = Decimal128; Object.defineProperty(Decimal128.prototype, '_bsontype', { value: 'Decimal128' }); }, 127: (__unused_webpack_module, exports) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.Double = void 0; let Double = (function () { function Double(value) { if (!(this instanceof Double)) return new Double(value); if (value instanceof Number) { value = value.valueOf() } this.value = +value } Double.prototype.valueOf = function () { return this.value }; Double.prototype.toJSON = function () { return this.value }; Double.prototype.toExtendedJSON = function (options) { if (options && (options.legacy || options.relaxed && isFinite(this.value))) { return this.value } if (Object.is(Math.sign(this.value), -0)) { return { $numberDouble: "-" + this.value.toFixed(1) } } var $numberDouble; if (Number.isInteger(this.value)) { $numberDouble = this.value.toFixed(1); if ($numberDouble.length >= 13) { $numberDouble = this.value.toExponential(13).toUpperCase() } } else { $numberDouble = this.value.toString() } return { $numberDouble: $numberDouble } }; Double.fromExtendedJSON = function (doc, options) { var doubleValue = parseFloat(doc.$numberDouble); return options && options.relaxed ? doubleValue : new Double(doubleValue) }; Double.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return this.inspect() }; Double.prototype.inspect = function () { var eJSON = this.toExtendedJSON(); return "new Double(" + eJSON.$numberDouble + ")" }; return Double }()); exports.Double = Double; Object.defineProperty(Double.prototype, '_bsontype', { value: 'Double' }); }, 404: (__unused_webpack_module, exports, __nccwpck_require__) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.ensureBuffer = void 0; let buffer_1 = __nccwpck_require__(293); let utils_1 = __nccwpck_require__(775); function ensureBuffer(potentialBuffer) { if (ArrayBuffer.isView(potentialBuffer)) { return buffer_1.Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength); } if (utils_1.isAnyArrayBuffer(potentialBuffer)) { return buffer_1.Buffer.from(potentialBuffer); } throw new TypeError('Must use either Buffer or TypedArray'); } exports.ensureBuffer = ensureBuffer; }, 177: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, '__esModule', { value: true }); exports.EJSON = exports.isBSONType = void 0; let binary_1 = __nccwpck_require__(362); let code_1 = __nccwpck_require__(974); let db_ref_1 = __nccwpck_require__(458); let decimal128_1 = __nccwpck_require__(407); let double_1 = __nccwpck_require__(127); let int_32_1 = __nccwpck_require__(194); let long_1 = __nccwpck_require__(152); let max_key_1 = __nccwpck_require__(979); let min_key_1 = __nccwpck_require__(162); let objectid_1 = __nccwpck_require__(909); let utils_1 = __nccwpck_require__(775); let regexp_1 = __nccwpck_require__(352); let symbol_1 = __nccwpck_require__(120); let timestamp_1 = __nccwpck_require__(481); function isBSONType(value) { return utils_1.isObjectLike(value) && Reflect.has(value, '_bsontype') && typeof value._bsontype === 'string' } exports.isBSONType = isBSONType; let BSON_INT32_MAX = 2147483647; let BSON_INT32_MIN = -2147483648; let BSON_INT64_MAX = 0x8000000000000000; let BSON_INT64_MIN = -0x8000000000000000; let keysToCodecs = {
        $oid: objectid_1.ObjectId, $binary: binary_1.Binary, $uuid: binary_1.Binary, $symbol: symbol_1.BSONSymbol, $numberInt: int_32_1.Int32, $numberDecimal: decimal128_1.Decimal128, $numberDouble: double_1.Double, $numberLong: long_1.Long, $minKey: min_key_1.MinKey, $maxKey: max_key_1.MaxKey, $regex: regexp_1.BSONRegExp, $regularExpression: regexp_1.BSONRegExp, $timestamp: timestamp_1.Timestamp
      }; function deserializeValue(value, options) { if (options === void 0) { options = {}; } if (typeof value === 'number') { if (options.relaxed || options.legacy) { return value; } if (Math.floor(value) === value) { if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) return new int_32_1.Int32(value); if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) return long_1.Long.fromNumber(value); } return new double_1.Double(value); } if (value == null || typeof value !== 'object') return value; if (value.$undefined) return null; let keys = Object.keys(value).filter((k) => { return k.startsWith('$') && value[k] != null }); for (let i = 0; i < keys.length; i++) { let c = keysToCodecs[keys[i]]; if (c) return c.fromExtendedJSON(value, options); } if (value.$date != null) { let d = value.$date; let date = new Date(); if (options.legacy) { if (typeof d === 'number') date.setTime(d); else if (typeof d === 'string') date.setTime(Date.parse(d)); } else if (typeof d === "string") date.setTime(Date.parse(d)); else if (long_1.Long.isLong(d)) date.setTime(d.toNumber()); else if (typeof d === "number" && options.relaxed) date.setTime(d); return date; } if (value.$code != null) { let copy = { ...value }; if (value.$scope) { copy.$scope = deserializeValue(value.$scope); } return code_1.Code.fromExtendedJSON(value); } if (value.$ref != null || value.$dbPointer != null) { let v = value.$ref ? value : value.$dbPointer; if (v instanceof db_ref_1.DBRef) return v; let dollarKeys = Object.keys(v).filter((k) => { return k.startsWith('$') }); let valid_1 = true; dollarKeys.forEach((k) => { if (['$ref', "$id", "$db"].indexOf(k) === -1) valid_1 = false }); if (valid_1) return db_ref_1.DBRef.fromExtendedJSON(v); } return value; } function serializeArray(array, options) { return array.map((v, index) => { options.seenObjects.push({ propertyName: "index " + index, obj: null }); try { return serializeValue(v, options) } finally { options.seenObjects.pop() } }); } function getISOString(date) { let isoStr = date.toISOString(); return date.getUTCMilliseconds() !== 0 ? isoStr : `${isoStr.slice(0, -5)}Z` } function serializeValue(value, options) { if ((typeof value === 'object' || typeof value === 'function') && value !== null) { let index = options.seenObjects.findIndex((entry) => { return entry.obj === value }); if (index !== -1) { let props = options.seenObjects.map((entry) => { return entry.propertyName }); let leadingPart = props.slice(0, index).map((prop) => { return `${prop} -> ` }).join(''); let alreadySeen = props[index]; let circularPart = ' -> ' + props.slice(index + 1, props.length - 1).map((prop) => { return `${prop} -> ` }).join(''); let current = props[props.length - 1]; let leadingSpace = ' '.repeat(leadingPart.length + alreadySeen.length / 2); let dashes = '-'.repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1); throw new TypeError(`Converting circular structure to EJSON:\n` + `    ${leadingPart}${alreadySeen}${circularPart}${current}\n` + `    ${leadingSpace}\\${dashes}/`); } options.seenObjects[options.seenObjects.length - 1].obj = value; } if (Array.isArray(value)) return serializeArray(value, options); if (value === undefined) return null; if (value instanceof Date || utils_1.isDate(value)) { let dateNum = value.getTime(); let inRange = dateNum > -1 && dateNum < 2534023188e5; if (options.legacy) { return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) }; } return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } }; } if (typeof value === 'number' && !options.relaxed) { if (Math.floor(value) === value) { let int32Range = value >= BSON_INT32_MIN && value <= BSON_INT32_MAX; let int64Range = value >= BSON_INT64_MIN && value <= BSON_INT64_MAX; if (int32Range) return { $numberInt: value.toString() }; if (int64Range) return { $numberLong: value.toString() }; } return { $numberDouble: value.toString() }; } if (value instanceof RegExp || utils_1.isRegExp(value)) { let { flags } = value; if (flags === undefined) { let match = value.toString().match(/[gimuy]*$/); if (match) { flags = match[0]; } } let rx = new regexp_1.BSONRegExp(value.source, flags); return rx.toExtendedJSON(options); } if (value != null && typeof value === 'object') return serializeDocument(value, options); return value; } let BSON_TYPE_MAPPINGS = {
        Binary(o) { return new binary_1.Binary(o.value(), o.sub_type) }, Code(o) { return new code_1.Code(o.code, o.scope) }, DBRef(o) { return new db_ref_1.DBRef(o.collection || o.namespace, o.oid, o.db, o.fields) }, Decimal128(o) { return new decimal128_1.Decimal128(o.bytes) }, Double(o) { return new double_1.Double(o.value) }, Int32(o) { return new int_32_1.Int32(o.value) }, Long(o) { return long_1.Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_) }, MaxKey() { return new max_key_1.MaxKey() }, MinKey() { return new min_key_1.MinKey() }, ObjectID(o) { return new objectid_1.ObjectId(o) }, ObjectId(o) { return new objectid_1.ObjectId(o) }, BSONRegExp(o) { return new regexp_1.BSONRegExp(o.pattern, o.options) }, Symbol(o) { return new symbol_1.BSONSymbol(o.value) }, Timestamp(o) { return timestamp_1.Timestamp.fromBits(o.low, o.high) }
      }; function serializeDocument(doc, options) { if (doc == null || typeof doc !== "object") throw new Error('not an object instance'); var bsontype = doc._bsontype; if (typeof bsontype === "undefined") { var _doc = {}; for (let name in doc) { options.seenObjects.push({ propertyName: name, obj: null }); try { _doc[name] = serializeValue(doc[name], options) } finally { options.seenObjects.pop() } } return _doc } if (isBSONType(doc)) { var outDoc = doc; if (typeof outDoc.toExtendedJSON !== "function") { var mapper = BSON_TYPE_MAPPINGS[doc._bsontype]; if (!mapper) { throw new TypeError('Unrecognized or invalid _bsontype: ' + doc._bsontype) } outDoc = mapper(outDoc) } if (bsontype === "Code" && outDoc.scope) { outDoc = new code_1.Code(outDoc.code, serializeValue(outDoc.scope, options)) } else if (bsontype === "DBRef" && outDoc.oid) { outDoc = new db_ref_1.DBRef(outDoc.collection, serializeValue(outDoc.oid, options), outDoc.db, outDoc.fields) } return outDoc.toExtendedJSON(options) } else { throw new Error('_bsontype must be a string, but was: ' + typeof bsontype) } } let EJSON; (function (EJSON) { function parse(text, options) { let finalOptions = { relaxed: true, legacy: false, ...options }; if (typeof finalOptions.relaxed === 'boolean') finalOptions.strict = !finalOptions.relaxed; if (typeof finalOptions.strict === 'boolean') finalOptions.relaxed = !finalOptions.strict; return JSON.parse(text, (_key, value) => { return deserializeValue(value, finalOptions) }); } EJSON.parse = parse; function stringify(value, replacer, space, options) { if (space != null && typeof space === 'object') { options = space; space = 0; } if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) { options = replacer; replacer = undefined; space = 0; } let serializeOptions = { relaxed: true, legacy: false, ...options, seenObjects: [{ propertyName: "(root)", obj: null }] }; let doc = serializeValue(value, serializeOptions); return JSON.stringify(doc, replacer, space); } EJSON.stringify = stringify; function serialize(value, options) { options = options || {}; return JSON.parse(stringify(value, options)); } EJSON.serialize = serialize; function deserialize(ejson, options) { options = options || {}; return parse(JSON.stringify(ejson), options); } EJSON.deserialize = deserialize; }(EJSON = exports.EJSON || (exports.EJSON = {})))
    }, 465: (__unused_webpack_module, exports) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.writeIEEE754 = exports.readIEEE754 = void 0; function readIEEE754(buffer, offset, endian, mLen, nBytes) { let e; let m; let bBE = endian === 'big'; let eLen = nBytes * 8 - mLen - 1; let eMax = (1 << eLen) - 1; let eBias = eMax >> 1; let nBits = -7; let i = bBE ? 0 : nBytes - 1; let d = bBE ? 1 : -1; let s = buffer[offset + i]; i += d; e = s & (1 << -nBits) - 1; s >>= -nBits; nBits += eLen; for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8); m = e & (1 << -nBits) - 1; e >>= -nBits; nBits += mLen; for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8); if (e === 0) { e = 1 - eBias; } else if (e === eMax) { return m ? NaN : (s ? -1 : 1) * Infinity; } else { m += Math.pow(2, mLen); e -= eBias } return (s ? -1 : 1) * m * Math.pow(2, e - mLen); } exports.readIEEE754 = readIEEE754; function writeIEEE754(buffer, value, offset, endian, mLen, nBytes) { let e; let m; let c; let bBE = endian === 'big'; let eLen = nBytes * 8 - mLen - 1; let eMax = (1 << eLen) - 1; let eBias = eMax >> 1; let rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0; let i = bBE ? nBytes - 1 : 0; let d = bBE ? -1 : 1; let s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0; value = Math.abs(value); if (isNaN(value) || value === Infinity) { m = isNaN(value) ? 1 : 0; e = eMax; } else { e = Math.floor(Math.log(value) / Math.LN2); if (value * (c = Math.pow(2, -e)) < 1) { e--; c *= 2; } if (e + eBias >= 1) { value += rt / c; } else { value += rt * Math.pow(2, 1 - eBias); } if (value * c >= 2) { e++; c /= 2; } if (e + eBias >= eMax) { m = 0; e = eMax; } else if (e + eBias >= 1) { m = (value * c - 1) * Math.pow(2, mLen); e += eBias } else { m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen); e = 0; } } if (isNaN(value)) m = 0; while (mLen >= 8) { buffer[offset + i] = m & 255; i += d; m /= 256; mLen -= 8; } e = e << mLen | m; if (isNaN(value)) e += 8; eLen += mLen; while (eLen > 0) { buffer[offset + i] = e & 255; i += d; e /= 256; eLen -= 8; } buffer[offset + i - d] |= s * 128; } exports.writeIEEE754 = writeIEEE754; }, 194: (__unused_webpack_module, exports) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.Int32 = void 0; let Int32 = (function () { function Int32(value) { if (!(this instanceof Int32)) return new Int32(value); if (value instanceof Number) { value = value.valueOf() } this.value = +value } Int32.prototype.valueOf = function () { return this.value }; Int32.prototype.toJSON = function () { return this.value }; Int32.prototype.toExtendedJSON = function (options) { if (options && (options.relaxed || options.legacy)) return this.value; return { $numberInt: this.value.toString() } }; Int32.fromExtendedJSON = function (doc, options) { return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt) }; Int32.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return this.inspect() }; Int32.prototype.inspect = function () { return "new Int32(" + this.valueOf() + ")" }; return Int32 }()); exports.Int32 = Int32; Object.defineProperty(Int32.prototype, '_bsontype', { value: 'Int32' }); }, 152: (__unused_webpack_module, exports, __nccwpck_require__) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.Long = void 0; let utils_1 = __nccwpck_require__(775); let wasm = undefined; try { wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports; } catch (_a) { } let TWO_PWR_16_DBL = 1 << 16; let TWO_PWR_24_DBL = 1 << 24; let TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL; let TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL; let TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2; let INT_CACHE = {}; let UINT_CACHE = {}; let Long = (function () { function Long(low, high, unsigned) { if (low === void 0) { low = 0 } if (!(this instanceof Long)) return new Long(low, high, unsigned); if (typeof low === "bigint") { Object.assign(this, Long.fromBigInt(low, !!high)) } else if (typeof low === "string") { Object.assign(this, Long.fromString(low, !!high)) } else { this.low = low | 0; this.high = high | 0; this.unsigned = !!unsigned } Object.defineProperty(this, "__isLong__", { value: true, configurable: false, writable: false, enumerable: false }) } Long.fromBits = function (lowBits, highBits, unsigned) { return new Long(lowBits, highBits, unsigned) }; Long.fromInt = function (value, unsigned) { var obj; var cachedObj; var cache; if (unsigned) { value >>>= 0; if (cache = 0 <= value && value < 256) { cachedObj = UINT_CACHE[value]; if (cachedObj) return cachedObj } obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true); if (cache) UINT_CACHE[value] = obj; return obj } else { value |= 0; if (cache = -128 <= value && value < 128) { cachedObj = INT_CACHE[value]; if (cachedObj) return cachedObj } obj = Long.fromBits(value, value < 0 ? -1 : 0, false); if (cache) INT_CACHE[value] = obj; return obj } }; Long.fromNumber = function (value, unsigned) { if (isNaN(value)) return unsigned ? Long.UZERO : Long.ZERO; if (unsigned) { if (value < 0) return Long.UZERO; if (value >= TWO_PWR_64_DBL) return Long.MAX_UNSIGNED_VALUE } else { if (value <= -TWO_PWR_63_DBL) return Long.MIN_VALUE; if (value + 1 >= TWO_PWR_63_DBL) return Long.MAX_VALUE } if (value < 0) return Long.fromNumber(-value, unsigned).neg(); return Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned) }; Long.fromBigInt = function (value, unsigned) { return Long.fromString(value.toString(), unsigned) }; Long.fromString = function (str, unsigned, radix) { if (str.length === 0) throw Error('empty string'); if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return Long.ZERO; if (typeof unsigned === "number") { radix = unsigned, unsigned = false } else { unsigned = !!unsigned } radix = radix || 10; if (radix < 2 || 36 < radix) throw RangeError('radix'); var p; if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen'); else if (p === 0) { return Long.fromString(str.substring(1), unsigned, radix).neg() } var radixToPower = Long.fromNumber(Math.pow(radix, 8)); var result = Long.ZERO; for (let i = 0; i < str.length; i += 8) { var size = Math.min(8, str.length - i); var value = parseInt(str.substring(i, i + size), radix); if (size < 8) { var power = Long.fromNumber(Math.pow(radix, size)); result = result.mul(power).add(Long.fromNumber(value)) } else { result = result.mul(radixToPower); result = result.add(Long.fromNumber(value)) } } result.unsigned = unsigned; return result }; Long.fromBytes = function (bytes, unsigned, le) { return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned) }; Long.fromBytesLE = function (bytes, unsigned) { return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned) }; Long.fromBytesBE = function (bytes, unsigned) { return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned) }; Long.isLong = function (value) { return utils_1.isObjectLike(value) && value.__isLong__ === true }; Long.fromValue = function (val, unsigned) { if (typeof val === "number") return Long.fromNumber(val, unsigned); if (typeof val === "string") return Long.fromString(val, unsigned); return Long.fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned) }; Long.prototype.add = function (addend) { if (!Long.isLong(addend)) addend = Long.fromValue(addend); var a48 = this.high >>> 16; var a32 = this.high & 65535; var a16 = this.low >>> 16; var a00 = this.low & 65535; var b48 = addend.high >>> 16; var b32 = addend.high & 65535; var b16 = addend.low >>> 16; var b00 = addend.low & 65535; var c48 = 0; var c32 = 0; var c16 = 0; var c00 = 0; c00 += a00 + b00; c16 += c00 >>> 16; c00 &= 65535; c16 += a16 + b16; c32 += c16 >>> 16; c16 &= 65535; c32 += a32 + b32; c48 += c32 >>> 16; c32 &= 65535; c48 += a48 + b48; c48 &= 65535; return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned) }; Long.prototype.and = function (other) { if (!Long.isLong(other)) other = Long.fromValue(other); return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned) }; Long.prototype.compare = function (other) { if (!Long.isLong(other)) other = Long.fromValue(other); if (this.eq(other)) return 0; var thisNeg = this.isNegative(); var otherNeg = other.isNegative(); if (thisNeg && !otherNeg) return -1; if (!thisNeg && otherNeg) return 1; if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1 }; Long.prototype.comp = function (other) { return this.compare(other) }; Long.prototype.divide = function (divisor) { if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor); if (divisor.isZero()) throw Error('division by zero'); if (wasm) { if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) { return this } var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high); return Long.fromBits(low, wasm.get_high(), this.unsigned) } if (this.isZero()) return this.unsigned ? Long.UZERO : Long.ZERO; var approx; var rem; var res; if (!this.unsigned) { if (this.eq(Long.MIN_VALUE)) { if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE)) return Long.MIN_VALUE; else if (divisor.eq(Long.MIN_VALUE)) return Long.ONE; else { var halfThis = this.shr(1); approx = halfThis.div(divisor).shl(1); if (approx.eq(Long.ZERO)) { return divisor.isNegative() ? Long.ONE : Long.NEG_ONE } else { rem = this.sub(divisor.mul(approx)); res = approx.add(rem.div(divisor)); return res } } } else if (divisor.eq(Long.MIN_VALUE)) return this.unsigned ? Long.UZERO : Long.ZERO; if (this.isNegative()) { if (divisor.isNegative()) return this.neg().div(divisor.neg()); return this.neg().div(divisor).neg() } else if (divisor.isNegative()) return this.div(divisor.neg()).neg(); res = Long.ZERO } else { if (!divisor.unsigned) divisor = divisor.toUnsigned(); if (divisor.gt(this)) return Long.UZERO; if (divisor.gt(this.shru(1))) return Long.UONE; res = Long.UZERO } rem = this; while (rem.gte(divisor)) { approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); var log2 = Math.ceil(Math.log(approx) / Math.LN2); var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48); var approxRes = Long.fromNumber(approx); var approxRem = approxRes.mul(divisor); while (approxRem.isNegative() || approxRem.gt(rem)) { approx -= delta; approxRes = Long.fromNumber(approx, this.unsigned); approxRem = approxRes.mul(divisor) } if (approxRes.isZero()) approxRes = Long.ONE; res = res.add(approxRes); rem = rem.sub(approxRem) } return res }; Long.prototype.div = function (divisor) { return this.divide(divisor) }; Long.prototype.equals = function (other) { if (!Long.isLong(other)) other = Long.fromValue(other); if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false; return this.high === other.high && this.low === other.low }; Long.prototype.eq = function (other) { return this.equals(other) }; Long.prototype.getHighBits = function () { return this.high }; Long.prototype.getHighBitsUnsigned = function () { return this.high >>> 0 }; Long.prototype.getLowBits = function () { return this.low }; Long.prototype.getLowBitsUnsigned = function () { return this.low >>> 0 }; Long.prototype.getNumBitsAbs = function () { if (this.isNegative()) { return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs() } var val = this.high !== 0 ? this.high : this.low; var bit; for (bit = 31; bit > 0; bit--) if ((val & 1 << bit) !== 0) break; return this.high !== 0 ? bit + 33 : bit + 1 }; Long.prototype.greaterThan = function (other) { return this.comp(other) > 0 }; Long.prototype.gt = function (other) { return this.greaterThan(other) }; Long.prototype.greaterThanOrEqual = function (other) { return this.comp(other) >= 0 }; Long.prototype.gte = function (other) { return this.greaterThanOrEqual(other) }; Long.prototype.ge = function (other) { return this.greaterThanOrEqual(other) }; Long.prototype.isEven = function () { return (this.low & 1) === 0 }; Long.prototype.isNegative = function () { return !this.unsigned && this.high < 0 }; Long.prototype.isOdd = function () { return (this.low & 1) === 1 }; Long.prototype.isPositive = function () { return this.unsigned || this.high >= 0 }; Long.prototype.isZero = function () { return this.high === 0 && this.low === 0 }; Long.prototype.lessThan = function (other) { return this.comp(other) < 0 }; Long.prototype.lt = function (other) { return this.lessThan(other) }; Long.prototype.lessThanOrEqual = function (other) { return this.comp(other) <= 0 }; Long.prototype.lte = function (other) { return this.lessThanOrEqual(other) }; Long.prototype.modulo = function (divisor) { if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor); if (wasm) { var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high); return Long.fromBits(low, wasm.get_high(), this.unsigned) } return this.sub(this.div(divisor).mul(divisor)) }; Long.prototype.mod = function (divisor) { return this.modulo(divisor) }; Long.prototype.rem = function (divisor) { return this.modulo(divisor) }; Long.prototype.multiply = function (multiplier) { if (this.isZero()) return Long.ZERO; if (!Long.isLong(multiplier)) multiplier = Long.fromValue(multiplier); if (wasm) { var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high); return Long.fromBits(low, wasm.get_high(), this.unsigned) } if (multiplier.isZero()) return Long.ZERO; if (this.eq(Long.MIN_VALUE)) return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO; if (multiplier.eq(Long.MIN_VALUE)) return this.isOdd() ? Long.MIN_VALUE : Long.ZERO; if (this.isNegative()) { if (multiplier.isNegative()) return this.neg().mul(multiplier.neg()); else return this.neg().mul(multiplier).neg() } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24)) return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); var a48 = this.high >>> 16; var a32 = this.high & 65535; var a16 = this.low >>> 16; var a00 = this.low & 65535; var b48 = multiplier.high >>> 16; var b32 = multiplier.high & 65535; var b16 = multiplier.low >>> 16; var b00 = multiplier.low & 65535; var c48 = 0; var c32 = 0; var c16 = 0; var c00 = 0; c00 += a00 * b00; c16 += c00 >>> 16; c00 &= 65535; c16 += a16 * b00; c32 += c16 >>> 16; c16 &= 65535; c16 += a00 * b16; c32 += c16 >>> 16; c16 &= 65535; c32 += a32 * b00; c48 += c32 >>> 16; c32 &= 65535; c32 += a16 * b16; c48 += c32 >>> 16; c32 &= 65535; c32 += a00 * b32; c48 += c32 >>> 16; c32 &= 65535; c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48; c48 &= 65535; return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned) }; Long.prototype.mul = function (multiplier) { return this.multiply(multiplier) }; Long.prototype.negate = function () { if (!this.unsigned && this.eq(Long.MIN_VALUE)) return Long.MIN_VALUE; return this.not().add(Long.ONE) }; Long.prototype.neg = function () { return this.negate() }; Long.prototype.not = function () { return Long.fromBits(~this.low, ~this.high, this.unsigned) }; Long.prototype.notEquals = function (other) { return !this.equals(other) }; Long.prototype.neq = function (other) { return this.notEquals(other) }; Long.prototype.ne = function (other) { return this.notEquals(other) }; Long.prototype.or = function (other) { if (!Long.isLong(other)) other = Long.fromValue(other); return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned) }; Long.prototype.shiftLeft = function (numBits) { if (Long.isLong(numBits)) numBits = numBits.toInt(); if ((numBits &= 63) === 0) return this; else if (numBits < 32) return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned); else return Long.fromBits(0, this.low << numBits - 32, this.unsigned) }; Long.prototype.shl = function (numBits) { return this.shiftLeft(numBits) }; Long.prototype.shiftRight = function (numBits) { if (Long.isLong(numBits)) numBits = numBits.toInt(); if ((numBits &= 63) === 0) return this; else if (numBits < 32) return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned); else return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned) }; Long.prototype.shr = function (numBits) { return this.shiftRight(numBits) }; Long.prototype.shiftRightUnsigned = function (numBits) { if (Long.isLong(numBits)) numBits = numBits.toInt(); numBits &= 63; if (numBits === 0) return this; else { var { high } = this; if (numBits < 32) { var { low } = this; return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned) } else if (numBits === 32) return Long.fromBits(high, 0, this.unsigned); else return Long.fromBits(high >>> numBits - 32, 0, this.unsigned) } }; Long.prototype.shr_u = function (numBits) { return this.shiftRightUnsigned(numBits) }; Long.prototype.shru = function (numBits) { return this.shiftRightUnsigned(numBits) }; Long.prototype.subtract = function (subtrahend) { if (!Long.isLong(subtrahend)) subtrahend = Long.fromValue(subtrahend); return this.add(subtrahend.neg()) }; Long.prototype.sub = function (subtrahend) { return this.subtract(subtrahend) }; Long.prototype.toInt = function () { return this.unsigned ? this.low >>> 0 : this.low }; Long.prototype.toNumber = function () { if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0); return this.high * TWO_PWR_32_DBL + (this.low >>> 0) }; Long.prototype.toBigInt = function () { return BigInt(this.toString()) }; Long.prototype.toBytes = function (le) { return le ? this.toBytesLE() : this.toBytesBE() }; Long.prototype.toBytesLE = function () { var hi = this.high; var lo = this.low; return [lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi & 255, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24] }; Long.prototype.toBytesBE = function () { var hi = this.high; var lo = this.low; return [hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, hi & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255] }; Long.prototype.toSigned = function () { if (!this.unsigned) return this; return Long.fromBits(this.low, this.high, false) }; Long.prototype.toString = function (radix) { radix = radix || 10; if (radix < 2 || 36 < radix) throw RangeError('radix'); if (this.isZero()) return "0"; if (this.isNegative()) { if (this.eq(Long.MIN_VALUE)) { var radixLong = Long.fromNumber(radix); var div = this.div(radixLong); var rem1 = div.mul(radixLong).sub(this); return div.toString(radix) + rem1.toInt().toString(radix) } else return "-" + this.neg().toString(radix) } var radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned); var rem = this; var result = ""; while (true) { var remDiv = rem.div(radixToPower); var intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0; var digits = intval.toString(radix); rem = remDiv; if (rem.isZero()) { return digits + result } else { while (digits.length < 6) digits = "0" + digits; result = "" + digits + result } } }; Long.prototype.toUnsigned = function () { if (this.unsigned) return this; return Long.fromBits(this.low, this.high, true) }; Long.prototype.xor = function (other) { if (!Long.isLong(other)) other = Long.fromValue(other); return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned) }; Long.prototype.eqz = function () { return this.isZero() }; Long.prototype.le = function (other) { return this.lessThanOrEqual(other) }; Long.prototype.toExtendedJSON = function (options) { if (options && options.relaxed) return this.toNumber(); return { $numberLong: this.toString() } }; Long.fromExtendedJSON = function (doc, options) { var result = Long.fromString(doc.$numberLong); return options && options.relaxed ? result.toNumber() : result }; Long.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return this.inspect() }; Long.prototype.inspect = function () { return 'new Long("' + this.toString() + '"' + (this.unsigned ? ", true" : '') + ")" }; Long.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL); Long.MAX_UNSIGNED_VALUE = Long.fromBits(4294967295 | 0, 4294967295 | 0, true); Long.ZERO = Long.fromInt(0); Long.UZERO = Long.fromInt(0, true); Long.ONE = Long.fromInt(1); Long.UONE = Long.fromInt(1, true); Long.NEG_ONE = Long.fromInt(-1); Long.MAX_VALUE = Long.fromBits(4294967295 | 0, 2147483647 | 0, false); Long.MIN_VALUE = Long.fromBits(0, 2147483648 | 0, false); return Long }()); exports.Long = Long; Object.defineProperty(Long.prototype, '__isLong__', { value: true }); Object.defineProperty(Long.prototype, '_bsontype', { value: 'Long' }); }, 361: (__unused_webpack_module, exports) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.Map = void 0; let bsonMap; exports.Map = bsonMap; let check = function (potentialGlobal) { return potentialGlobal && potentialGlobal.Math == Math && potentialGlobal; }; function getGlobal() { return check(typeof globalThis === 'object' && globalThis) || check(typeof window === 'object' && window) || check(typeof self === 'object' && self) || check(typeof global === 'object' && global) || Function('return this')(); } let bsonGlobal = getGlobal(); if (Object.prototype.hasOwnProperty.call(bsonGlobal, 'Map')) { exports.Map = bsonMap = bsonGlobal.Map; } else { exports.Map = bsonMap = (function () { function Map(array) { if (array === void 0) { array = [] } this._keys = []; this._values = {}; for (let i = 0; i < array.length; i++) { if (array[i] == null) continue; var entry = array[i]; var key = entry[0]; var value = entry[1]; this._keys.push(key); this._values[key] = { v: value, i: this._keys.length - 1 } } } Map.prototype.clear = function () { this._keys = []; this._values = {} }; Map.prototype.delete = function (key) { var value = this._values[key]; if (value == null) return false; delete this._values[key]; this._keys.splice(value.i, 1); return true }; Map.prototype.entries = function () { var _this = this; var index = 0; return { next: function () { var key = _this._keys[index++]; return { value: key !== undefined ? [key, _this._values[key].v] : undefined, done: key !== undefined ? false : true } } } }; Map.prototype.forEach = function (callback, self) { self = self || this; for (let i = 0; i < this._keys.length; i++) { var key = this._keys[i]; callback.call(self, this._values[key].v, key, self) } }; Map.prototype.get = function (key) { return this._values[key] ? this._values[key].v : undefined }; Map.prototype.has = function (key) { return this._values[key] != null }; Map.prototype.keys = function () { var _this = this; var index = 0; return { next: function () { var key = _this._keys[index++]; return { value: key !== undefined ? key : undefined, done: key !== undefined ? false : true } } } }; Map.prototype.set = function (key, value) { if (this._values[key]) { this._values[key].v = value; return this } this._keys.push(key); this._values[key] = { v: value, i: this._keys.length - 1 }; return this }; Map.prototype.values = function () { var _this = this; var index = 0; return { next: function () { var key = _this._keys[index++]; return { value: key !== undefined ? _this._values[key].v : undefined, done: key !== undefined ? false : true } } } }; Object.defineProperty(Map.prototype, "size", { get: function () { return this._keys.length }, enumerable: false, configurable: true }); return Map }()) } }, 979: (__unused_webpack_module, exports) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.MaxKey = void 0; let MaxKey = (function () { function MaxKey() { if (!(this instanceof MaxKey)) return new MaxKey() } MaxKey.prototype.toExtendedJSON = function () { return { $maxKey: 1 } }; MaxKey.fromExtendedJSON = function () { return new MaxKey() }; MaxKey.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return this.inspect() }; MaxKey.prototype.inspect = function () { return "new MaxKey()" }; return MaxKey }()); exports.MaxKey = MaxKey; Object.defineProperty(MaxKey.prototype, '_bsontype', { value: 'MaxKey' }); }, 162: (__unused_webpack_module, exports) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.MinKey = void 0; let MinKey = (function () { function MinKey() { if (!(this instanceof MinKey)) return new MinKey() } MinKey.prototype.toExtendedJSON = function () { return { $minKey: 1 } }; MinKey.fromExtendedJSON = function () { return new MinKey() }; MinKey.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return this.inspect() }; MinKey.prototype.inspect = function () { return "new MinKey()" }; return MinKey }()); exports.MinKey = MinKey; Object.defineProperty(MinKey.prototype, '_bsontype', { value: 'MinKey' }); }, 909: (__unused_webpack_module, exports, __nccwpck_require__) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.ObjectId = void 0; let buffer_1 = __nccwpck_require__(293); let ensure_buffer_1 = __nccwpck_require__(404); let utils_1 = __nccwpck_require__(775); let checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$'); let PROCESS_UNIQUE = null; let kId = Symbol('id'); let ObjectId = (function () { function ObjectId(id) { if (!(this instanceof ObjectId)) return new ObjectId(id); if (id instanceof ObjectId) { this[kId] = id.id; this.__id = id.__id } if (typeof id === "object" && id && "id" in id) { if ('toHexString' in id && typeof id.toHexString === "function") { this[kId] = buffer_1.Buffer.from(id.toHexString(), "hex") } else { this[kId] = typeof id.id === "string" ? buffer_1.Buffer.from(id.id) : id.id } } if (id == null || typeof id === "number") { this[kId] = ObjectId.generate(typeof id === "number" ? id : undefined); if (ObjectId.cacheHexString) { this.__id = this.id.toString('hex') } } if (ArrayBuffer.isView(id) && id.byteLength === 12) { this[kId] = ensure_buffer_1.ensureBuffer(id) } if (typeof id === "string") { if (id.length === 12) { var bytes = buffer_1.Buffer.from(id); if (bytes.byteLength === 12) { this[kId] = bytes } } else if (id.length === 24 && checkForHexRegExp.test(id)) { this[kId] = buffer_1.Buffer.from(id, "hex") } else { throw new TypeError('Argument passed in must be a Buffer or string of 12 bytes or a string of 24 hex characters') } } if (ObjectId.cacheHexString) { this.__id = this.id.toString('hex') } } Object.defineProperty(ObjectId.prototype, "id", { get: function () { return this[kId] }, set: function (value) { this[kId] = value; if (ObjectId.cacheHexString) { this.__id = value.toString('hex') } }, enumerable: false, configurable: true }); Object.defineProperty(ObjectId.prototype, "generationTime", { get: function () { return this.id.readInt32BE(0) }, set: function (value) { this.id.writeUInt32BE(value, 0) }, enumerable: false, configurable: true }); ObjectId.prototype.toHexString = function () { if (ObjectId.cacheHexString && this.__id) { return this.__id } var hexString = this.id.toString('hex'); if (ObjectId.cacheHexString && !this.__id) { this.__id = hexString } return hexString }; ObjectId.getInc = function () { return ObjectId.index = (ObjectId.index + 1) % 16777215 }; ObjectId.generate = function (time) { if ('number' !== typeof time) { time = ~~(Date.now() / 1e3) } var inc = ObjectId.getInc(); var buffer = buffer_1.Buffer.alloc(12); buffer.writeUInt32BE(time, 0); if (PROCESS_UNIQUE === null) { PROCESS_UNIQUE = utils_1.randomBytes(5) } buffer[4] = PROCESS_UNIQUE[0]; buffer[5] = PROCESS_UNIQUE[1]; buffer[6] = PROCESS_UNIQUE[2]; buffer[7] = PROCESS_UNIQUE[3]; buffer[8] = PROCESS_UNIQUE[4]; buffer[11] = inc & 255; buffer[10] = inc >> 8 & 255; buffer[9] = inc >> 16 & 255; return buffer }; ObjectId.prototype.toString = function (format) { if (format) return this.id.toString(format); return this.toHexString() }; ObjectId.prototype.toJSON = function () { return this.toHexString() }; ObjectId.prototype.equals = function (otherId) { if (otherId === undefined || otherId === null) { return false } if (otherId instanceof ObjectId) { return this.toString() === otherId.toString() } if (typeof otherId === "string" && ObjectId.isValid(otherId) && otherId.length === 12 && utils_1.isUint8Array(this.id)) { return otherId === buffer_1.Buffer.prototype.toString.call(this.id, "latin1") } if (typeof otherId === "string" && ObjectId.isValid(otherId) && otherId.length === 24) { return otherId.toLowerCase() === this.toHexString() } if (typeof otherId === "string" && ObjectId.isValid(otherId) && otherId.length === 12) { return buffer_1.Buffer.from(otherId).equals(this.id) } if (typeof otherId === "object" && "toHexString" in otherId && typeof otherId.toHexString === "function") { return otherId.toHexString() === this.toHexString() } return false }; ObjectId.prototype.getTimestamp = function () { var timestamp = new Date(); var time = this.id.readUInt32BE(0); timestamp.setTime(Math.floor(time) * 1e3); return timestamp }; ObjectId.createPk = function () { return new ObjectId() }; ObjectId.createFromTime = function (time) { var buffer = buffer_1.Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]); buffer.writeUInt32BE(time, 0); return new ObjectId(buffer) }; ObjectId.createFromHexString = function (hexString) { if (typeof hexString === "undefined" || hexString != null && hexString.length !== 24) { throw new TypeError('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters') } return new ObjectId(buffer_1.Buffer.from(hexString, "hex")) }; ObjectId.isValid = function (id) { if (id == null) return false; if (typeof id === "number") { return true } if (typeof id === "string") { return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id) } if (id instanceof ObjectId) { return true } if (utils_1.isUint8Array(id) && id.length === 12) { return true } if (typeof id === "object" && "toHexString" in id && typeof id.toHexString === "function") { if (typeof id.id === "string") { return id.id.length === 12 } return id.toHexString().length === 24 && checkForHexRegExp.test(id.id.toString('hex')) } return false }; ObjectId.prototype.toExtendedJSON = function () { if (this.toHexString) return { $oid: this.toHexString() }; return { $oid: this.toString('hex') } }; ObjectId.fromExtendedJSON = function (doc) { return new ObjectId(doc.$oid) }; ObjectId.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return this.inspect() }; ObjectId.prototype.inspect = function () { return 'new ObjectId("' + this.toHexString() + '")' }; ObjectId.index = ~~(Math.random() * 16777215); return ObjectId }()); exports.ObjectId = ObjectId; Object.defineProperty(ObjectId.prototype, 'generate', { value: utils_1.deprecate((time) => { return ObjectId.generate(time) }, 'Please use the static `ObjectId.generate(time)` instead') }); Object.defineProperty(ObjectId.prototype, 'getInc', { value: utils_1.deprecate(() => { return ObjectId.getInc() }, 'Please use the static `ObjectId.getInc()` instead') }); Object.defineProperty(ObjectId.prototype, 'get_inc', { value: utils_1.deprecate(() => { return ObjectId.getInc() }, 'Please use the static `ObjectId.getInc()` instead') }); Object.defineProperty(ObjectId, 'get_inc', { value: utils_1.deprecate(() => { return ObjectId.getInc() }, 'Please use the static `ObjectId.getInc()` instead') }); Object.defineProperty(ObjectId.prototype, '_bsontype', { value: 'ObjectID' }); }, 906: (__unused_webpack_module, exports, __nccwpck_require__) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.calculateObjectSize = void 0; let buffer_1 = __nccwpck_require__(293); let binary_1 = __nccwpck_require__(362); let constants = __nccwpck_require__(550); let utils_1 = __nccwpck_require__(775); function calculateObjectSize(object, serializeFunctions, ignoreUndefined) { let totalLength = 4 + 1; if (Array.isArray(object)) { for (let i = 0; i < object.length; i++) { totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined); } } else { if (object.toBSON) { object = object.toBSON(); } for (const key in object) { totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined); } } return totalLength; } exports.calculateObjectSize = calculateObjectSize; function calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) { if (serializeFunctions === void 0) { serializeFunctions = false } if (isArray === void 0) { isArray = false } if (ignoreUndefined === void 0) { ignoreUndefined = false } if (value && value.toBSON) { value = value.toBSON() } switch (typeof value) { case "string": return 1 + buffer_1.Buffer.byteLength(name, "utf8") + 1 + 4 + buffer_1.Buffer.byteLength(value, "utf8") + 1; case "number": if (Math.floor(value) === value && value >= constants.JS_INT_MIN && value <= constants.JS_INT_MAX) { if (value >= constants.BSON_INT32_MIN && value <= constants.BSON_INT32_MAX) { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (4 + 1) } return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1) } else { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1) } case "undefined": if (isArray || !ignoreUndefined) return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1; return 0; case "boolean": return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 1); case "object": if (value == null || value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 } else if (value._bsontype === 'ObjectId' || value._bsontype === 'ObjectID') { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (12 + 1) } else if (value instanceof Date || utils_1.isDate(value)) { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1) } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || utils_1.isAnyArrayBuffer(value)) { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 4 + 1) + value.byteLength } else if (value._bsontype === 'Long' || value._bsontype === 'Double' || value._bsontype === 'Timestamp') { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1) } else if (value._bsontype === 'Decimal128') { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (16 + 1) } else if (value._bsontype === 'Code') { if (value.scope != null && Object.keys(value.scope).length > 0) { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + buffer_1.Buffer.byteLength(value.code.toString(), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined) } else { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + buffer_1.Buffer.byteLength(value.code.toString(), "utf8") + 1 } } else if (value._bsontype === 'Binary') { if (value.sub_type === binary_1.Binary.SUBTYPE_BYTE_ARRAY) { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1 + 4) } else { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1) } } else if (value._bsontype === 'Symbol') { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + buffer_1.Buffer.byteLength(value.value, "utf8") + 4 + 1 + 1 } else if (value._bsontype === 'DBRef') { var ordered_values = Object.assign({ $ref: value.collection, $id: value.oid }, value.fields); if (value.db != null) { ordered_values.$db = value.db } return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined) } else if (value instanceof RegExp || utils_1.isRegExp(value)) { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + buffer_1.Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1 } else if (value._bsontype === 'BSONRegExp') { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + buffer_1.Buffer.byteLength(value.pattern, "utf8") + 1 + buffer_1.Buffer.byteLength(value.options, "utf8") + 1 } else { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + calculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1 } case "function": if (value instanceof RegExp || utils_1.isRegExp(value) || String.call(value) === "[object RegExp]") { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + buffer_1.Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1 } else { if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + buffer_1.Buffer.byteLength(utils_1.normalizedFunctionString(value), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined) } else if (serializeFunctions) { return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + buffer_1.Buffer.byteLength(utils_1.normalizedFunctionString(value), "utf8") + 1 } } } return 0 } }, 973: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, '__esModule', { value: true }); exports.deserialize = void 0; let buffer_1 = __nccwpck_require__(293); let binary_1 = __nccwpck_require__(362); let code_1 = __nccwpck_require__(974); let constants = __nccwpck_require__(550); let db_ref_1 = __nccwpck_require__(458); let decimal128_1 = __nccwpck_require__(407); let double_1 = __nccwpck_require__(127); let int_32_1 = __nccwpck_require__(194); let long_1 = __nccwpck_require__(152); let max_key_1 = __nccwpck_require__(979); let min_key_1 = __nccwpck_require__(162); let objectid_1 = __nccwpck_require__(909); let regexp_1 = __nccwpck_require__(352); let symbol_1 = __nccwpck_require__(120); let timestamp_1 = __nccwpck_require__(481); let validate_utf8_1 = __nccwpck_require__(862); let JS_INT_MAX_LONG = long_1.Long.fromNumber(constants.JS_INT_MAX); let JS_INT_MIN_LONG = long_1.Long.fromNumber(constants.JS_INT_MIN); let functionCache = {}; function deserialize(buffer, options, isArray) { options = options == null ? {} : options; let index = options && options.index ? options.index : 0; let size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24; if (size < 5) { throw new Error(`bson size must be >= 5, is ${size}`); } if (options.allowObjectSmallerThanBufferSize && buffer.length < size) { throw new Error(`buffer length ${buffer.length} must be >= bson size ${size}`); } if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) { throw new Error(`buffer length ${buffer.length} must === bson size ${size}`); } if (size + index > buffer.byteLength) { throw new Error(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`); } if (buffer[index + size - 1] !== 0) { throw new Error('One object, sized correctly, with a spot for an EOO, but the EOO isn\'t 0x00'); } return deserializeObject(buffer, index, options, isArray); } exports.deserialize = deserialize; function deserializeObject(buffer, index, options, isArray) {
        if (isArray === void 0) { isArray = false; } let evalFunctions = options.evalFunctions == null ? false : options.evalFunctions; let cacheFunctions = options.cacheFunctions == null ? false : options.cacheFunctions; let fieldsAsRaw = options.fieldsAsRaw == null ? null : options.fieldsAsRaw; let raw = options.raw == null ? false : options.raw; let bsonRegExp = typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false; let promoteBuffers = options.promoteBuffers == null ? false : options.promoteBuffers; let promoteLongs = options.promoteLongs == null ? true : options.promoteLongs; let promoteValues = options.promoteValues == null ? true : options.promoteValues; let startIndex = index; if (buffer.length < 5) throw new Error('corrupt bson message < 5 bytes long'); let size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; if (size < 5 || size > buffer.length) throw new Error('corrupt bson message'); let object = isArray ? [] : {}; let arrayIndex = 0; let done = false; while (!done) {
          let elementType = buffer[index++]; if (elementType === 0) break; let i = index; while (buffer[i] !== 0 && i < buffer.length) { i++; } if (i >= buffer.byteLength) throw new Error('Bad BSON Document: illegal CString'); let name = isArray ? arrayIndex++ : buffer.toString('utf8', index, i); let value = void 0; index = i + 1; if (elementType === constants.BSON_DATA_STRING) { var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson'); if (!validate_utf8_1.validateUtf8(buffer, index, index + stringSize - 1)) { throw new Error('Invalid UTF-8 string in BSON document'); } value = buffer.toString('utf8', index, index + stringSize - 1); index += stringSize } else if (elementType === constants.BSON_DATA_OID) { var oid = buffer_1.Buffer.alloc(12); buffer.copy(oid, 0, index, index + 12); value = new objectid_1.ObjectId(oid); index += 12 } else if (elementType === constants.BSON_DATA_INT && promoteValues === false) { value = new int_32_1.Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24); } else if (elementType === constants.BSON_DATA_INT) { value = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; } else if (elementType === constants.BSON_DATA_NUMBER && promoteValues === false) { value = new double_1.Double(buffer.readDoubleLE(index)); index += 8 } else if (elementType === constants.BSON_DATA_NUMBER) { value = buffer.readDoubleLE(index); index += 8 } else if (elementType === constants.BSON_DATA_DATE) { var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; value = new Date(new long_1.Long(lowBits, highBits).toNumber()); } else if (elementType === constants.BSON_DATA_BOOLEAN) { if (buffer[index] !== 0 && buffer[index] !== 1) throw new Error('illegal boolean type value'); value = buffer[index++] === 1; } else if (elementType === constants.BSON_DATA_OBJECT) { var _index = index; var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24; if (objectSize <= 0 || objectSize > buffer.length - index) throw new Error('bad embedded document length in bson'); if (raw) { value = buffer.slice(index, index + objectSize); } else { value = deserializeObject(buffer, _index, options, false); } index += objectSize } else if (elementType === constants.BSON_DATA_ARRAY) { var _index = index; var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24; let arrayOptions = options; let stopIndex = index + objectSize; if (fieldsAsRaw && fieldsAsRaw[name]) { arrayOptions = {}; for (const n in options) { arrayOptions[n] = options[n]; } arrayOptions.raw = true; } value = deserializeObject(buffer, _index, arrayOptions, true); index += objectSize; if (buffer[index - 1] !== 0) throw new Error('invalid array terminator byte'); if (index !== stopIndex) throw new Error('corrupted array bson'); } else if (elementType === constants.BSON_DATA_UNDEFINED) { value = undefined; } else if (elementType === constants.BSON_DATA_NULL) { value = null; } else if (elementType === constants.BSON_DATA_LONG) { var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; let long = new long_1.Long(lowBits, highBits); if (promoteLongs && promoteValues === true) { value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long; } else { value = long; } } else if (elementType === constants.BSON_DATA_DECIMAL128) { let bytes = buffer_1.Buffer.alloc(16); buffer.copy(bytes, 0, index, index + 16); index += 16; let decimal128 = new decimal128_1.Decimal128(bytes); if ('toObject' in decimal128 && typeof decimal128.toObject === 'function') { value = decimal128.toObject(); } else { value = decimal128; } } else if (elementType === constants.BSON_DATA_BINARY) { let binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; let totalBinarySize = binarySize; let subType = buffer[index++]; if (binarySize < 0) throw new Error('Negative binary type element size found'); if (binarySize > buffer.byteLength) throw new Error('Binary type size larger than document size'); if (buffer.slice != null) { if (subType === binary_1.Binary.SUBTYPE_BYTE_ARRAY) { binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; if (binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02'); if (binarySize > totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains too long binary size'); if (binarySize < totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains too short binary size'); } if (promoteBuffers && promoteValues) { value = buffer.slice(index, index + binarySize); } else { value = new binary_1.Binary(buffer.slice(index, index + binarySize), subType); } } else { let _buffer = buffer_1.Buffer.alloc(binarySize); if (subType === binary_1.Binary.SUBTYPE_BYTE_ARRAY) { binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; if (binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02'); if (binarySize > totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains too long binary size'); if (binarySize < totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains too short binary size'); } for (i = 0; i < binarySize; i++) { _buffer[i] = buffer[index + i]; } if (promoteBuffers && promoteValues) { value = _buffer; } else { value = new binary_1.Binary(_buffer, subType); } } index += binarySize } else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === false) { i = index; while (buffer[i] !== 0 && i < buffer.length) { i++; } if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString'); var source = buffer.toString('utf8', index, i); index = i + 1; i = index; while (buffer[i] !== 0 && i < buffer.length) { i++; } if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString'); var regExpOptions = buffer.toString('utf8', index, i); index = i + 1; let optionsArray = new Array(regExpOptions.length); for (i = 0; i < regExpOptions.length; i++) { switch (regExpOptions[i]) { case 'm': optionsArray[i] = 'm'; break; case 's': optionsArray[i] = 'g'; break; case 'i': optionsArray[i] = 'i'; break; } } value = new RegExp(source, optionsArray.join('')); } else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === true) { i = index; while (buffer[i] !== 0 && i < buffer.length) { i++; } if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString'); var source = buffer.toString('utf8', index, i); index = i + 1; i = index; while (buffer[i] !== 0 && i < buffer.length) { i++; } if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString'); var regExpOptions = buffer.toString('utf8', index, i); index = i + 1; value = new regexp_1.BSONRegExp(source, regExpOptions); } else if (elementType === constants.BSON_DATA_SYMBOL) { var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson'); let symbol = buffer.toString('utf8', index, index + stringSize - 1); value = promoteValues ? symbol : new symbol_1.BSONSymbol(symbol); index += stringSize } else if (elementType === constants.BSON_DATA_TIMESTAMP) { var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; value = new timestamp_1.Timestamp(lowBits, highBits); } else if (elementType === constants.BSON_DATA_MIN_KEY) { value = new min_key_1.MinKey() } else if (elementType === constants.BSON_DATA_MAX_KEY) { value = new max_key_1.MaxKey() } else if (elementType === constants.BSON_DATA_CODE) { var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson'); var functionString = buffer.toString('utf8', index, index + stringSize - 1); if (evalFunctions) { if (cacheFunctions) { value = isolateEval(functionString, functionCache, object); } else { value = isolateEval(functionString); } } else { value = new code_1.Code(functionString); } index += stringSize } else if (elementType === constants.BSON_DATA_CODE_W_SCOPE) { let totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; if (totalSize < 4 + 4 + 4 + 1) { throw new Error('code_w_scope total size shorter minimum expected length'); } var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson'); var functionString = buffer.toString('utf8', index, index + stringSize - 1); index += stringSize; var _index = index; var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24; let scopeObject = deserializeObject(buffer, _index, options, false); index += objectSize; if (totalSize < 4 + 4 + objectSize + stringSize) { throw new Error('code_w_scope total size is too short, truncating scope'); } if (totalSize > 4 + 4 + objectSize + stringSize) { throw new Error('code_w_scope total size is too long, clips outer document'); } if (evalFunctions) { if (cacheFunctions) { value = isolateEval(functionString, functionCache, object); } else { value = isolateEval(functionString); } value.scope = scopeObject; } else { value = new code_1.Code(functionString, scopeObject); } } else if (elementType === constants.BSON_DATA_DBPOINTER) { var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson'); if (!validate_utf8_1.validateUtf8(buffer, index, index + stringSize - 1)) { throw new Error('Invalid UTF-8 string in BSON document'); } let namespace = buffer.toString('utf8', index, index + stringSize - 1); index += stringSize; let oidBuffer = buffer_1.Buffer.alloc(12); buffer.copy(oidBuffer, 0, index, index + 12); var oid = new objectid_1.ObjectId(oidBuffer); index += 12; value = new db_ref_1.DBRef(namespace, oid); } else { throw new Error(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`); } if (name === '__proto__') {
            Object.defineProperty(object, name, {
              value, writable: true, enumerable: true, configurable: true
            });
          } else { object[name] = value; }
        } if (size !== index - startIndex) { if (isArray) throw new Error('corrupt array bson'); throw new Error('corrupt object bson'); } let dollarKeys = Object.keys(object).filter((k) => { return k.startsWith('$') }); let valid = true; dollarKeys.forEach((k) => { if (['$ref', "$id", "$db"].indexOf(k) === -1) valid = false }); if (!valid) return object; if (db_ref_1.isDBRefLike(object)) { let copy = { ...object }; delete copy.$ref; delete copy.$id; delete copy.$db; return new db_ref_1.DBRef(object.$ref, object.$id, object.$db, copy); } return object;
      } function isolateEval(functionString, functionCache, object) { if (!functionCache) return new Function(functionString); if (functionCache[functionString] == null) { functionCache[functionString] = new Function(functionString); } return functionCache[functionString].bind(object); }
    }, 305: (__unused_webpack_module, exports, __nccwpck_require__) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.serializeInto = void 0; let binary_1 = __nccwpck_require__(362); let constants = __nccwpck_require__(550); let ensure_buffer_1 = __nccwpck_require__(404); let extended_json_1 = __nccwpck_require__(177); let float_parser_1 = __nccwpck_require__(465); let long_1 = __nccwpck_require__(152); let map_1 = __nccwpck_require__(361); let utils_1 = __nccwpck_require__(775); let regexp = /\x00/; let ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']); function serializeString(buffer, key, value, index, isArray) { buffer[index++] = constants.BSON_DATA_STRING; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index = index + numberOfWrittenBytes + 1; buffer[index - 1] = 0; let size = buffer.write(value, index + 4, undefined, 'utf8'); buffer[index + 3] = size + 1 >> 24 & 255; buffer[index + 2] = size + 1 >> 16 & 255; buffer[index + 1] = size + 1 >> 8 & 255; buffer[index] = size + 1 & 255; index = index + 4 + size; buffer[index++] = 0; return index; } function serializeNumber(buffer, key, value, index, isArray) { if (Number.isInteger(value) && value >= constants.BSON_INT32_MIN && value <= constants.BSON_INT32_MAX) { buffer[index++] = constants.BSON_DATA_INT; var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; buffer[index++] = value & 255; buffer[index++] = value >> 8 & 255; buffer[index++] = value >> 16 & 255; buffer[index++] = value >> 24 & 255; } else { buffer[index++] = constants.BSON_DATA_NUMBER; var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; float_parser_1.writeIEEE754(buffer, value, index, 'little', 52, 8); index += 8 } return index; } function serializeNull(buffer, key, _, index, isArray) { buffer[index++] = constants.BSON_DATA_NULL; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; return index; } function serializeBoolean(buffer, key, value, index, isArray) { buffer[index++] = constants.BSON_DATA_BOOLEAN; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; buffer[index++] = value ? 1 : 0; return index; } function serializeDate(buffer, key, value, index, isArray) { buffer[index++] = constants.BSON_DATA_DATE; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; let dateInMilis = long_1.Long.fromNumber(value.getTime()); let lowBits = dateInMilis.getLowBits(); let highBits = dateInMilis.getHighBits(); buffer[index++] = lowBits & 255; buffer[index++] = lowBits >> 8 & 255; buffer[index++] = lowBits >> 16 & 255; buffer[index++] = lowBits >> 24 & 255; buffer[index++] = highBits & 255; buffer[index++] = highBits >> 8 & 255; buffer[index++] = highBits >> 16 & 255; buffer[index++] = highBits >> 24 & 255; return index; } function serializeRegExp(buffer, key, value, index, isArray) { buffer[index++] = constants.BSON_DATA_REGEXP; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; if (value.source && value.source.match(regexp) != null) { throw Error(`value ${value.source} must not contain null bytes`); } index += buffer.write(value.source, index, undefined, "utf8"); buffer[index++] = 0; if (value.ignoreCase) buffer[index++] = 105; if (value.global) buffer[index++] = 115; if (value.multiline) buffer[index++] = 109; buffer[index++] = 0; return index; } function serializeBSONRegExp(buffer, key, value, index, isArray) { buffer[index++] = constants.BSON_DATA_REGEXP; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; if (value.pattern.match(regexp) != null) { throw Error(`pattern ${value.pattern} must not contain null bytes`); } index += buffer.write(value.pattern, index, undefined, "utf8"); buffer[index++] = 0; index += buffer.write(value.options.split('').sort().join(''), index, undefined, "utf8"); buffer[index++] = 0; return index; } function serializeMinMax(buffer, key, value, index, isArray) { if (value === null) { buffer[index++] = constants.BSON_DATA_NULL; } else if (value._bsontype === 'MinKey') { buffer[index++] = constants.BSON_DATA_MIN_KEY; } else { buffer[index++] = constants.BSON_DATA_MAX_KEY; } let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; return index; } function serializeObjectId(buffer, key, value, index, isArray) { buffer[index++] = constants.BSON_DATA_OID; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; if (typeof value.id === 'string') { buffer.write(value.id, index, undefined, 'binary'); } else if (value.id && value.id.copy) { value.id.copy(buffer, index, 0, 12); } else { throw new TypeError(`object [${JSON.stringify(value)}] is not a valid ObjectId`); } return index + 12; } function serializeBuffer(buffer, key, value, index, isArray) { buffer[index++] = constants.BSON_DATA_BINARY; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; let size = value.length; buffer[index++] = size & 255; buffer[index++] = size >> 8 & 255; buffer[index++] = size >> 16 & 255; buffer[index++] = size >> 24 & 255; buffer[index++] = constants.BSON_BINARY_SUBTYPE_DEFAULT; buffer.set(ensure_buffer_1.ensureBuffer(value), index); index += size; return index; } function serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) { if (checkKeys === void 0) { checkKeys = false; } if (depth === void 0) { depth = 0; } if (serializeFunctions === void 0) { serializeFunctions = false; } if (ignoreUndefined === void 0) { ignoreUndefined = true; } if (isArray === void 0) { isArray = false; } if (path === void 0) { path = []; } for (let i = 0; i < path.length; i++) { if (path[i] === value) throw new Error('cyclic dependency detected'); } path.push(value); buffer[index++] = Array.isArray(value) ? constants.BSON_DATA_ARRAY : constants.BSON_DATA_OBJECT; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; let endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path); path.pop(); return endIndex; } function serializeDecimal128(buffer, key, value, index, isArray) { buffer[index++] = constants.BSON_DATA_DECIMAL128; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; value.bytes.copy(buffer, index, 0, 16); return index + 16; } function serializeLong(buffer, key, value, index, isArray) { buffer[index++] = value._bsontype === 'Long' ? constants.BSON_DATA_LONG : constants.BSON_DATA_TIMESTAMP; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; let lowBits = value.getLowBits(); let highBits = value.getHighBits(); buffer[index++] = lowBits & 255; buffer[index++] = lowBits >> 8 & 255; buffer[index++] = lowBits >> 16 & 255; buffer[index++] = lowBits >> 24 & 255; buffer[index++] = highBits & 255; buffer[index++] = highBits >> 8 & 255; buffer[index++] = highBits >> 16 & 255; buffer[index++] = highBits >> 24 & 255; return index; } function serializeInt32(buffer, key, value, index, isArray) { value = value.valueOf(); buffer[index++] = constants.BSON_DATA_INT; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; buffer[index++] = value & 255; buffer[index++] = value >> 8 & 255; buffer[index++] = value >> 16 & 255; buffer[index++] = value >> 24 & 255; return index; } function serializeDouble(buffer, key, value, index, isArray) { buffer[index++] = constants.BSON_DATA_NUMBER; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; float_parser_1.writeIEEE754(buffer, value.value, index, 'little', 52, 8); index += 8; return index; } function serializeFunction(buffer, key, value, index, _checkKeys, _depth, isArray) { if (_checkKeys === void 0) { _checkKeys = false; } if (_depth === void 0) { _depth = 0; } buffer[index++] = constants.BSON_DATA_CODE; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; let functionString = utils_1.normalizedFunctionString(value); let size = buffer.write(functionString, index + 4, undefined, 'utf8') + 1; buffer[index] = size & 255; buffer[index + 1] = size >> 8 & 255; buffer[index + 2] = size >> 16 & 255; buffer[index + 3] = size >> 24 & 255; index = index + 4 + size - 1; buffer[index++] = 0; return index; } function serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) { if (checkKeys === void 0) { checkKeys = false; } if (depth === void 0) { depth = 0; } if (serializeFunctions === void 0) { serializeFunctions = false; } if (ignoreUndefined === void 0) { ignoreUndefined = true; } if (isArray === void 0) { isArray = false; } if (value.scope && typeof value.scope === 'object') { buffer[index++] = constants.BSON_DATA_CODE_W_SCOPE; var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; let startIndex = index; var functionString = typeof value.code === 'string' ? value.code : value.code.toString(); index += 4; let codeSize = buffer.write(functionString, index + 4, undefined, 'utf8') + 1; buffer[index] = codeSize & 255; buffer[index + 1] = codeSize >> 8 & 255; buffer[index + 2] = codeSize >> 16 & 255; buffer[index + 3] = codeSize >> 24 & 255; buffer[index + 4 + codeSize - 1] = 0; index = index + codeSize + 4; let endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined); index = endIndex - 1; let totalSize = endIndex - startIndex; buffer[startIndex++] = totalSize & 255; buffer[startIndex++] = totalSize >> 8 & 255; buffer[startIndex++] = totalSize >> 16 & 255; buffer[startIndex++] = totalSize >> 24 & 255; buffer[index++] = 0; } else { buffer[index++] = constants.BSON_DATA_CODE; var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; var functionString = value.code.toString(); let size = buffer.write(functionString, index + 4, undefined, 'utf8') + 1; buffer[index] = size & 255; buffer[index + 1] = size >> 8 & 255; buffer[index + 2] = size >> 16 & 255; buffer[index + 3] = size >> 24 & 255; index = index + 4 + size - 1; buffer[index++] = 0; } return index; } function serializeBinary(buffer, key, value, index, isArray) { buffer[index++] = constants.BSON_DATA_BINARY; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; let data = value.value(true); let size = value.position; if (value.sub_type === binary_1.Binary.SUBTYPE_BYTE_ARRAY) size += 4; buffer[index++] = size & 255; buffer[index++] = size >> 8 & 255; buffer[index++] = size >> 16 & 255; buffer[index++] = size >> 24 & 255; buffer[index++] = value.sub_type; if (value.sub_type === binary_1.Binary.SUBTYPE_BYTE_ARRAY) { size -= 4; buffer[index++] = size & 255; buffer[index++] = size >> 8 & 255; buffer[index++] = size >> 16 & 255; buffer[index++] = size >> 24 & 255; } buffer.set(data, index); index += value.position; return index; } function serializeSymbol(buffer, key, value, index, isArray) { buffer[index++] = constants.BSON_DATA_SYMBOL; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; let size = buffer.write(value.value, index + 4, undefined, 'utf8') + 1; buffer[index] = size & 255; buffer[index + 1] = size >> 8 & 255; buffer[index + 2] = size >> 16 & 255; buffer[index + 3] = size >> 24 & 255; index = index + 4 + size - 1; buffer[index++] = 0; return index; } function serializeDBRef(buffer, key, value, index, depth, serializeFunctions, isArray) { buffer[index++] = constants.BSON_DATA_OBJECT; let numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii'); index += numberOfWrittenBytes; buffer[index++] = 0; let startIndex = index; let output = { $ref: value.collection || value.namespace, $id: value.oid }; if (value.db != null) { output.$db = value.db; } output = Object.assign(output, value.fields); let endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions); let size = endIndex - startIndex; buffer[startIndex++] = size & 255; buffer[startIndex++] = size >> 8 & 255; buffer[startIndex++] = size >> 16 & 255; buffer[startIndex++] = size >> 24 & 255; return endIndex; } function serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) { if (checkKeys === void 0) { checkKeys = false; } if (startingIndex === void 0) { startingIndex = 0; } if (depth === void 0) { depth = 0; } if (serializeFunctions === void 0) { serializeFunctions = false; } if (ignoreUndefined === void 0) { ignoreUndefined = true; } if (path === void 0) { path = []; } startingIndex = startingIndex || 0; path = path || []; path.push(object); let index = startingIndex + 4; if (Array.isArray(object)) { for (let i = 0; i < object.length; i++) { var key = '' + i; var value = object[i]; if (value && value.toBSON) { if (typeof value.toBSON !== 'function') throw new TypeError('toBSON is not a function'); value = value.toBSON(); } if (typeof value === 'string') { index = serializeString(buffer, key, value, index, true); } else if (typeof value === 'number') { index = serializeNumber(buffer, key, value, index, true); } else if (typeof value === 'bigint') { throw new TypeError('Unsupported type BigInt, please use Decimal128'); } else if (typeof value === 'boolean') { index = serializeBoolean(buffer, key, value, index, true); } else if (value instanceof Date || utils_1.isDate(value)) { index = serializeDate(buffer, key, value, index, true); } else if (value === undefined) { index = serializeNull(buffer, key, value, index, true); } else if (value === null) { index = serializeNull(buffer, key, value, index, true); } else if (value._bsontype === 'ObjectId' || value._bsontype === 'ObjectID') { index = serializeObjectId(buffer, key, value, index, true); } else if (utils_1.isUint8Array(value)) { index = serializeBuffer(buffer, key, value, index, true); } else if (value instanceof RegExp || utils_1.isRegExp(value)) { index = serializeRegExp(buffer, key, value, index, true); } else if (typeof value === 'object' && value._bsontype == null) { index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path); } else if (typeof value === 'object' && extended_json_1.isBSONType(value) && value._bsontype === 'Decimal128') { index = serializeDecimal128(buffer, key, value, index, true); } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') { index = serializeLong(buffer, key, value, index, true); } else if (value._bsontype === 'Double') { index = serializeDouble(buffer, key, value, index, true); } else if (typeof value === 'function' && serializeFunctions) { index = serializeFunction(buffer, key, value, index, checkKeys, depth, true); } else if (value._bsontype === 'Code') { index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true); } else if (value._bsontype === 'Binary') { index = serializeBinary(buffer, key, value, index, true); } else if (value._bsontype === 'Symbol') { index = serializeSymbol(buffer, key, value, index, true); } else if (value._bsontype === 'DBRef') { index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true); } else if (value._bsontype === 'BSONRegExp') { index = serializeBSONRegExp(buffer, key, value, index, true); } else if (value._bsontype === 'Int32') { index = serializeInt32(buffer, key, value, index, true); } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') { index = serializeMinMax(buffer, key, value, index, true); } else if (typeof value._bsontype !== 'undefined') { throw new TypeError(`Unrecognized or invalid _bsontype: ${value._bsontype}`); } } } else if (object instanceof map_1.Map || utils_1.isMap(object)) { let iterator = object.entries(); let done = false; while (!done) { let entry = iterator.next(); done = !!entry.done; if (done) continue; var key = entry.value[0]; var value = entry.value[1]; var type = typeof value; if (typeof key === 'string' && !ignoreKeys.has(key)) { if (key.match(regexp) != null) { throw Error(`key ${key} must not contain null bytes`); } if (checkKeys) { if (key[0] === '$') { throw Error(`key ${key} must not start with '$'`); } else if (~key.indexOf('.')) { throw Error(`key ${key} must not contain '.'`); } } } if (type === 'string') { index = serializeString(buffer, key, value, index); } else if (type === 'number') { index = serializeNumber(buffer, key, value, index); } else if (type === 'bigint' || utils_1.isBigInt64Array(value) || utils_1.isBigUInt64Array(value)) { throw new TypeError('Unsupported type BigInt, please use Decimal128'); } else if (type === 'boolean') { index = serializeBoolean(buffer, key, value, index); } else if (value instanceof Date || utils_1.isDate(value)) { index = serializeDate(buffer, key, value, index); } else if (value === null || value === undefined && ignoreUndefined === false) { index = serializeNull(buffer, key, value, index); } else if (value._bsontype === 'ObjectId' || value._bsontype === 'ObjectID') { index = serializeObjectId(buffer, key, value, index); } else if (utils_1.isUint8Array(value)) { index = serializeBuffer(buffer, key, value, index); } else if (value instanceof RegExp || utils_1.isRegExp(value)) { index = serializeRegExp(buffer, key, value, index); } else if (type === 'object' && value._bsontype == null) { index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path); } else if (type === 'object' && value._bsontype === 'Decimal128') { index = serializeDecimal128(buffer, key, value, index); } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') { index = serializeLong(buffer, key, value, index); } else if (value._bsontype === 'Double') { index = serializeDouble(buffer, key, value, index); } else if (value._bsontype === 'Code') { index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined); } else if (typeof value === 'function' && serializeFunctions) { index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions); } else if (value._bsontype === 'Binary') { index = serializeBinary(buffer, key, value, index); } else if (value._bsontype === 'Symbol') { index = serializeSymbol(buffer, key, value, index); } else if (value._bsontype === 'DBRef') { index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions); } else if (value._bsontype === 'BSONRegExp') { index = serializeBSONRegExp(buffer, key, value, index); } else if (value._bsontype === 'Int32') { index = serializeInt32(buffer, key, value, index); } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') { index = serializeMinMax(buffer, key, value, index); } else if (typeof value._bsontype !== 'undefined') { throw new TypeError(`Unrecognized or invalid _bsontype: ${value._bsontype}`); } } } else { if (object.toBSON) { if (typeof object.toBSON !== 'function') throw new TypeError('toBSON is not a function'); object = object.toBSON(); if (object != null && typeof object !== 'object') throw new TypeError('toBSON function did not return an object'); } for (var key in object) { var value = object[key]; if (value && value.toBSON) { if (typeof value.toBSON !== 'function') throw new TypeError('toBSON is not a function'); value = value.toBSON(); } var type = typeof value; if (typeof key === 'string' && !ignoreKeys.has(key)) { if (key.match(regexp) != null) { throw Error(`key ${key} must not contain null bytes`); } if (checkKeys) { if (key[0] === '$') { throw Error(`key ${key} must not start with '$'`); } else if (~key.indexOf('.')) { throw Error(`key ${key} must not contain '.'`); } } } if (type === 'string') { index = serializeString(buffer, key, value, index); } else if (type === 'number') { index = serializeNumber(buffer, key, value, index); } else if (type === 'bigint') { throw new TypeError('Unsupported type BigInt, please use Decimal128'); } else if (type === 'boolean') { index = serializeBoolean(buffer, key, value, index); } else if (value instanceof Date || utils_1.isDate(value)) { index = serializeDate(buffer, key, value, index); } else if (value === undefined) { if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index); } else if (value === null) { index = serializeNull(buffer, key, value, index); } else if (value._bsontype === 'ObjectId' || value._bsontype === 'ObjectID') { index = serializeObjectId(buffer, key, value, index); } else if (utils_1.isUint8Array(value)) { index = serializeBuffer(buffer, key, value, index); } else if (value instanceof RegExp || utils_1.isRegExp(value)) { index = serializeRegExp(buffer, key, value, index); } else if (type === 'object' && value._bsontype == null) { index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path); } else if (type === 'object' && value._bsontype === 'Decimal128') { index = serializeDecimal128(buffer, key, value, index); } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') { index = serializeLong(buffer, key, value, index); } else if (value._bsontype === 'Double') { index = serializeDouble(buffer, key, value, index); } else if (value._bsontype === 'Code') { index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined); } else if (typeof value === 'function' && serializeFunctions) { index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions); } else if (value._bsontype === 'Binary') { index = serializeBinary(buffer, key, value, index); } else if (value._bsontype === 'Symbol') { index = serializeSymbol(buffer, key, value, index); } else if (value._bsontype === 'DBRef') { index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions); } else if (value._bsontype === 'BSONRegExp') { index = serializeBSONRegExp(buffer, key, value, index); } else if (value._bsontype === 'Int32') { index = serializeInt32(buffer, key, value, index); } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') { index = serializeMinMax(buffer, key, value, index); } else if (typeof value._bsontype !== 'undefined') { throw new TypeError(`Unrecognized or invalid _bsontype: ${value._bsontype}`); } } } path.pop(); buffer[index++] = 0; let size = index - startingIndex; buffer[startingIndex++] = size & 255; buffer[startingIndex++] = size >> 8 & 255; buffer[startingIndex++] = size >> 16 & 255; buffer[startingIndex++] = size >> 24 & 255; return index; } exports.serializeInto = serializeInto; }, 775: (__unused_webpack_module, exports, __nccwpck_require__) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.deprecate = exports.isObjectLike = exports.isDate = exports.haveBuffer = exports.isMap = exports.isRegExp = exports.isBigUInt64Array = exports.isBigInt64Array = exports.isUint8Array = exports.isAnyArrayBuffer = exports.randomBytes = exports.normalizedFunctionString = void 0; let buffer_1 = __nccwpck_require__(293); function normalizedFunctionString(fn) { return fn.toString().replace('function(', 'function ('); } exports.normalizedFunctionString = normalizedFunctionString; let isReactNative = typeof global.navigator === 'object' && global.navigator.product === 'ReactNative'; let insecureWarning = isReactNative ? 'BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.' : 'BSON: No cryptographic implementation for random bytes present, falling back to a less secure implementation.'; let insecureRandomBytes = function insecureRandomBytes(size) { console.warn(insecureWarning); let result = buffer_1.Buffer.alloc(size); for (let i = 0; i < size; ++i)result[i] = Math.floor(Math.random() * 256); return result; }; let detectRandomBytes = function () { if (typeof window !== 'undefined') { let target_1 = window.crypto || window.msCrypto; if (target_1 && target_1.getRandomValues) { return function (size) { return target_1.getRandomValues(buffer_1.Buffer.alloc(size)); }; } } if (typeof global !== 'undefined' && global.crypto && global.crypto.getRandomValues) { return function (size) { return global.crypto.getRandomValues(buffer_1.Buffer.alloc(size)); }; } let requiredRandomBytes; try { requiredRandomBytes = __nccwpck_require__(417).randomBytes; } catch (e) { } return requiredRandomBytes || insecureRandomBytes; }; exports.randomBytes = detectRandomBytes(); function isAnyArrayBuffer(value) { return ['[object ArrayBuffer]', '[object SharedArrayBuffer]'].includes(Object.prototype.toString.call(value)); } exports.isAnyArrayBuffer = isAnyArrayBuffer; function isUint8Array(value) { return Object.prototype.toString.call(value) === '[object Uint8Array]' } exports.isUint8Array = isUint8Array; function isBigInt64Array(value) { return Object.prototype.toString.call(value) === '[object BigInt64Array]' } exports.isBigInt64Array = isBigInt64Array; function isBigUInt64Array(value) { return Object.prototype.toString.call(value) === '[object BigUint64Array]' } exports.isBigUInt64Array = isBigUInt64Array; function isRegExp(d) { return Object.prototype.toString.call(d) === '[object RegExp]' } exports.isRegExp = isRegExp; function isMap(d) { return Object.prototype.toString.call(d) === '[object Map]' } exports.isMap = isMap; function haveBuffer() { return typeof global !== 'undefined' && typeof global.Buffer !== 'undefined' } exports.haveBuffer = haveBuffer; function isDate(d) { return isObjectLike(d) && Object.prototype.toString.call(d) === '[object Date]' } exports.isDate = isDate; function isObjectLike(candidate) { return typeof candidate === 'object' && candidate !== null; } exports.isObjectLike = isObjectLike; function deprecate(fn, message) { if (typeof window === 'undefined' && typeof self === 'undefined') { return __nccwpck_require__(669).deprecate(fn, message); } let warned = false; function deprecated() { let args = []; for (let _i = 0; _i < arguments.length; _i++) { args[_i] = arguments[_i]; } if (!warned) { console.warn(message); warned = true; } return fn.apply(this, args); } return deprecated; } exports.deprecate = deprecate; }, 352: (__unused_webpack_module, exports) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.BSONRegExp = void 0; function alphabetize(str) { return str.split('').sort().join(''); } let BSONRegExp = (function () { function BSONRegExp(pattern, options) { if (!(this instanceof BSONRegExp)) return new BSONRegExp(pattern, options); this.pattern = pattern; this.options = options !== null && options !== void 0 ? options : ''; alphabetize(this.options); for (let i = 0; i < this.options.length; i++) { if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) { throw new Error('The regular expression option [' + this.options[i] + "] is not supported") } } } BSONRegExp.parseOptions = function (options) { return options ? options.split('').sort().join('') : '' }; BSONRegExp.prototype.toExtendedJSON = function (options) { options = options || {}; if (options.legacy) { return { $regex: this.pattern, $options: this.options } } return { $regularExpression: { pattern: this.pattern, options: this.options } } }; BSONRegExp.fromExtendedJSON = function (doc) { if ('$regex' in doc) { if (typeof doc.$regex !== "string") { if (doc.$regex._bsontype === "BSONRegExp") { return doc } } else { return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options)) } } if ('$regularExpression' in doc) { return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options)) } throw new TypeError('Unexpected BSONRegExp EJSON object form: ' + JSON.stringify(doc)) }; return BSONRegExp }()); exports.BSONRegExp = BSONRegExp; Object.defineProperty(BSONRegExp.prototype, '_bsontype', { value: 'BSONRegExp' }); }, 120: (__unused_webpack_module, exports) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.BSONSymbol = void 0; let BSONSymbol = (function () { function BSONSymbol(value) { if (!(this instanceof BSONSymbol)) return new BSONSymbol(value); this.value = value } BSONSymbol.prototype.valueOf = function () { return this.value }; BSONSymbol.prototype.toString = function () { return this.value }; BSONSymbol.prototype.inspect = function () { return 'new BSONSymbol("' + this.value + '")' }; BSONSymbol.prototype.toJSON = function () { return this.value }; BSONSymbol.prototype.toExtendedJSON = function () { return { $symbol: this.value } }; BSONSymbol.fromExtendedJSON = function (doc) { return new BSONSymbol(doc.$symbol) }; BSONSymbol.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return this.inspect() }; return BSONSymbol }()); exports.BSONSymbol = BSONSymbol; Object.defineProperty(BSONSymbol.prototype, '_bsontype', { value: 'Symbol' }); }, 481(__unused_webpack_module, exports, __nccwpck_require__) { var __extends = this && this.__extends || function () { var extendStatics = function (d, b) { extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b } || function (d, b) { for (let p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p] }; return extendStatics(d, b) }; return function (d, b) { if (typeof b !== "function" && b !== null) throw new TypeError('Class extends value ' + String(b) + " is not a constructor or null"); extendStatics(d, b); function __() { this.constructor = d } d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __()) } }(); Object.defineProperty(exports, "__esModule", { value: true }); exports.Timestamp = exports.LongWithoutOverridesClass = void 0; var long_1 = __nccwpck_require__(152); exports.LongWithoutOverridesClass = long_1.Long; var Timestamp = function (_super) { __extends(Timestamp, _super); function Timestamp(low, high) { var _this = this; if (!(_this instanceof Timestamp)) return new Timestamp(low, high); if (long_1.Long.isLong(low)) { _this = _super.call(this, low.low, low.high, true) || this } else { _this = _super.call(this, low, high, true) || this } Object.defineProperty(_this, "_bsontype", { value: "Timestamp", writable: false, configurable: false, enumerable: false }); return _this } Timestamp.prototype.toJSON = function () { return { $timestamp: this.toString() } }; Timestamp.fromInt = function (value) { return new Timestamp(long_1.Long.fromInt(value, true)) }; Timestamp.fromNumber = function (value) { return new Timestamp(long_1.Long.fromNumber(value, true)) }; Timestamp.fromBits = function (lowBits, highBits) { return new Timestamp(lowBits, highBits) }; Timestamp.fromString = function (str, optRadix) { return new Timestamp(long_1.Long.fromString(str, true, optRadix)) }; Timestamp.prototype.toExtendedJSON = function () { return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } } }; Timestamp.fromExtendedJSON = function (doc) { return new Timestamp(doc.$timestamp.i, doc.$timestamp.t) }; Timestamp.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return this.inspect() }; Timestamp.prototype.inspect = function () { return "new Timestamp(" + this.getLowBits().toString() + ", " + this.getHighBits().toString() + ")" }; Timestamp.MAX_VALUE = long_1.Long.MAX_UNSIGNED_VALUE; return Timestamp }(exports.LongWithoutOverridesClass); exports.Timestamp = Timestamp }, 809: (__unused_webpack_module, exports, __nccwpck_require__) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.UUID = void 0; let buffer_1 = __nccwpck_require__(293); let ensure_buffer_1 = __nccwpck_require__(404); let binary_1 = __nccwpck_require__(362); let uuid_utils_1 = __nccwpck_require__(577); let utils_1 = __nccwpck_require__(775); let BYTE_LENGTH = 16; let kId = Symbol('id'); let UUID = (function () { function UUID(input) { if (typeof input === "undefined") { this.id = UUID.generate() } else if (input instanceof UUID) { this[kId] = buffer_1.Buffer.from(input.id); this.__id = input.__id } else if (ArrayBuffer.isView(input) && input.byteLength === BYTE_LENGTH) { this.id = ensure_buffer_1.ensureBuffer(input) } else if (typeof input === "string") { this.id = uuid_utils_1.uuidHexStringToBuffer(input) } else { throw new TypeError('Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).') } } Object.defineProperty(UUID.prototype, "id", { get: function () { return this[kId] }, set: function (value) { this[kId] = value; if (UUID.cacheHexString) { this.__id = uuid_utils_1.bufferToUuidHexString(value) } }, enumerable: false, configurable: true }); UUID.prototype.toHexString = function (includeDashes) { if (includeDashes === void 0) { includeDashes = true } if (UUID.cacheHexString && this.__id) { return this.__id } var uuidHexString = uuid_utils_1.bufferToUuidHexString(this.id, includeDashes); if (UUID.cacheHexString) { this.__id = uuidHexString } return uuidHexString }; UUID.prototype.toString = function (encoding) { return encoding ? this.id.toString(encoding) : this.toHexString() }; UUID.prototype.toJSON = function () { return this.toHexString() }; UUID.prototype.equals = function (otherId) { if (!otherId) { return false } if (otherId instanceof UUID) { return otherId.id.equals(this.id) } try { return new UUID(otherId).id.equals(this.id) } catch (_a) { return false } }; UUID.prototype.toBinary = function () { return new binary_1.Binary(this.id, binary_1.Binary.SUBTYPE_UUID) }; UUID.generate = function () { var bytes = utils_1.randomBytes(BYTE_LENGTH); bytes[6] = bytes[6] & 15 | 64; bytes[8] = bytes[8] & 63 | 128; return buffer_1.Buffer.from(bytes) }; UUID.isValid = function (input) { if (!input) { return false } if (input instanceof UUID) { return true } if (typeof input === "string") { return uuid_utils_1.uuidValidateString(input) } if (utils_1.isUint8Array(input)) { if (input.length !== BYTE_LENGTH) { return false } try { return parseInt(input[6].toString(16)[0], 10) === binary_1.Binary.SUBTYPE_UUID } catch (_a) { return false } } return false }; UUID.createFromHexString = function (hexString) { var buffer = uuid_utils_1.uuidHexStringToBuffer(hexString); return new UUID(buffer) }; UUID.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () { return this.inspect() }; UUID.prototype.inspect = function () { return 'new UUID("' + this.toHexString() + '")' }; return UUID }()); exports.UUID = UUID; Object.defineProperty(UUID.prototype, '_bsontype', { value: 'UUID' }); }, 577: (__unused_webpack_module, exports, __nccwpck_require__) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.bufferToUuidHexString = exports.uuidHexStringToBuffer = exports.uuidValidateString = void 0; let buffer_1 = __nccwpck_require__(293); let VALIDATION_REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|[0-9a-f]{12}4[0-9a-f]{3}[89ab][0-9a-f]{15})$/i; let uuidValidateString = function (str) { return typeof str === 'string' && VALIDATION_REGEX.test(str); }; exports.uuidValidateString = uuidValidateString; let uuidHexStringToBuffer = function (hexString) { if (!exports.uuidValidateString(hexString)) { throw new TypeError('UUID string representations must be a 32 or 36 character hex string (dashes excluded/included). Format: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" or "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".'); } let sanitizedHexString = hexString.replace(/-/g, ''); return buffer_1.Buffer.from(sanitizedHexString, 'hex'); }; exports.uuidHexStringToBuffer = uuidHexStringToBuffer; let bufferToUuidHexString = function (buffer, includeDashes) { if (includeDashes === void 0) { includeDashes = true; } return includeDashes ? `${buffer.toString('hex', 0, 4)}-${buffer.toString('hex', 4, 6)}-${buffer.toString('hex', 6, 8)}-${buffer.toString('hex', 8, 10)}-${buffer.toString('hex', 10, 16)}` : buffer.toString('hex'); }; exports.bufferToUuidHexString = bufferToUuidHexString; }, 862: (__unused_webpack_module, exports) => { Object.defineProperty(exports, '__esModule', { value: true }); exports.validateUtf8 = void 0; let FIRST_BIT = 128; let FIRST_TWO_BITS = 192; let FIRST_THREE_BITS = 224; let FIRST_FOUR_BITS = 240; let FIRST_FIVE_BITS = 248; let TWO_BIT_CHAR = 192; let THREE_BIT_CHAR = 224; let FOUR_BIT_CHAR = 240; let CONTINUING_CHAR = 128; function validateUtf8(bytes, start, end) { let continuation = 0; for (let i = start; i < end; i += 1) { let byte = bytes[i]; if (continuation) { if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) { return false; } continuation -= 1; } else if (byte & FIRST_BIT) { if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) { continuation = 1; } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) { continuation = 2; } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) { continuation = 3; } else { return false; } } } return !continuation; } exports.validateUtf8 = validateUtf8; }, 293: module => { module.exports = require('buffer'); }, 417: module => { module.exports = require('crypto'); }, 669: module => { module.exports = require('util'); }
  }; let __webpack_module_cache__ = {}; function __nccwpck_require__(moduleId) { let cachedModule = __webpack_module_cache__[moduleId]; if (cachedModule !== undefined) { return cachedModule.exports; } let module = __webpack_module_cache__[moduleId] = { exports: {} }; let threw = true; try { __webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__); threw = false; } finally { if (threw) delete __webpack_module_cache__[moduleId]; } return module.exports; } if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = `${__dirname}/`; let __webpack_exports__ = {}; (() => {
    let exports = __webpack_exports__; Object.defineProperty(exports, '__esModule', { value: true }); exports.ObjectID = exports.Decimal128 = exports.BSONRegExp = exports.MaxKey = exports.MinKey = exports.Int32 = exports.Double = exports.Timestamp = exports.Long = exports.UUID = exports.ObjectId = exports.Binary = exports.DBRef = exports.BSONSymbol = exports.Map = exports.Code = exports.LongWithoutOverridesClass = exports.EJSON = exports.BSON_INT64_MIN = exports.BSON_INT64_MAX = exports.BSON_INT32_MIN = exports.BSON_INT32_MAX = exports.BSON_DATA_UNDEFINED = exports.BSON_DATA_TIMESTAMP = exports.BSON_DATA_SYMBOL = exports.BSON_DATA_STRING = exports.BSON_DATA_REGEXP = exports.BSON_DATA_OID = exports.BSON_DATA_OBJECT = exports.BSON_DATA_NUMBER = exports.BSON_DATA_NULL = exports.BSON_DATA_MIN_KEY = exports.BSON_DATA_MAX_KEY = exports.BSON_DATA_LONG = exports.BSON_DATA_INT = exports.BSON_DATA_DECIMAL128 = exports.BSON_DATA_DBPOINTER = exports.BSON_DATA_DATE = exports.BSON_DATA_CODE_W_SCOPE = exports.BSON_DATA_CODE = exports.BSON_DATA_BOOLEAN = exports.BSON_DATA_BINARY = exports.BSON_DATA_ARRAY = exports.BSON_BINARY_SUBTYPE_UUID_NEW = exports.BSON_BINARY_SUBTYPE_UUID = exports.BSON_BINARY_SUBTYPE_USER_DEFINED = exports.BSON_BINARY_SUBTYPE_MD5 = exports.BSON_BINARY_SUBTYPE_FUNCTION = exports.BSON_BINARY_SUBTYPE_DEFAULT = exports.BSON_BINARY_SUBTYPE_BYTE_ARRAY = void 0; exports.deserializeStream = exports.calculateObjectSize = exports.deserialize = exports.serializeWithBufferAndIndex = exports.serialize = exports.setInternalBufferSize = void 0; let buffer_1 = __nccwpck_require__(293); let binary_1 = __nccwpck_require__(362); Object.defineProperty(exports, 'Binary', { enumerable: true, get() { return binary_1.Binary } }); let code_1 = __nccwpck_require__(974); Object.defineProperty(exports, 'Code', { enumerable: true, get() { return code_1.Code } }); let db_ref_1 = __nccwpck_require__(458); Object.defineProperty(exports, 'DBRef', { enumerable: true, get() { return db_ref_1.DBRef } }); let decimal128_1 = __nccwpck_require__(407); Object.defineProperty(exports, 'Decimal128', { enumerable: true, get() { return decimal128_1.Decimal128 } }); let double_1 = __nccwpck_require__(127); Object.defineProperty(exports, 'Double', { enumerable: true, get() { return double_1.Double } }); let ensure_buffer_1 = __nccwpck_require__(404); let extended_json_1 = __nccwpck_require__(177); let int_32_1 = __nccwpck_require__(194); Object.defineProperty(exports, 'Int32', { enumerable: true, get() { return int_32_1.Int32 } }); let long_1 = __nccwpck_require__(152); Object.defineProperty(exports, 'Long', { enumerable: true, get() { return long_1.Long } }); let map_1 = __nccwpck_require__(361); Object.defineProperty(exports, 'Map', { enumerable: true, get() { return map_1.Map } }); let max_key_1 = __nccwpck_require__(979); Object.defineProperty(exports, 'MaxKey', { enumerable: true, get() { return max_key_1.MaxKey } }); let min_key_1 = __nccwpck_require__(162); Object.defineProperty(exports, 'MinKey', { enumerable: true, get() { return min_key_1.MinKey } }); let objectid_1 = __nccwpck_require__(909); Object.defineProperty(exports, 'ObjectId', { enumerable: true, get() { return objectid_1.ObjectId } }); Object.defineProperty(exports, 'ObjectID', { enumerable: true, get() { return objectid_1.ObjectId } }); let calculate_size_1 = __nccwpck_require__(906); let deserializer_1 = __nccwpck_require__(973); let serializer_1 = __nccwpck_require__(305); let regexp_1 = __nccwpck_require__(352); Object.defineProperty(exports, 'BSONRegExp', { enumerable: true, get() { return regexp_1.BSONRegExp } }); let symbol_1 = __nccwpck_require__(120); Object.defineProperty(exports, 'BSONSymbol', { enumerable: true, get() { return symbol_1.BSONSymbol } }); let timestamp_1 = __nccwpck_require__(481); Object.defineProperty(exports, 'Timestamp', { enumerable: true, get() { return timestamp_1.Timestamp } }); let uuid_1 = __nccwpck_require__(809); Object.defineProperty(exports, 'UUID', { enumerable: true, get() { return uuid_1.UUID } }); let constants_1 = __nccwpck_require__(550); Object.defineProperty(exports, 'BSON_BINARY_SUBTYPE_BYTE_ARRAY', { enumerable: true, get() { return constants_1.BSON_BINARY_SUBTYPE_BYTE_ARRAY } }); Object.defineProperty(exports, 'BSON_BINARY_SUBTYPE_DEFAULT', { enumerable: true, get() { return constants_1.BSON_BINARY_SUBTYPE_DEFAULT } }); Object.defineProperty(exports, 'BSON_BINARY_SUBTYPE_FUNCTION', { enumerable: true, get() { return constants_1.BSON_BINARY_SUBTYPE_FUNCTION } }); Object.defineProperty(exports, 'BSON_BINARY_SUBTYPE_MD5', { enumerable: true, get() { return constants_1.BSON_BINARY_SUBTYPE_MD5 } }); Object.defineProperty(exports, 'BSON_BINARY_SUBTYPE_USER_DEFINED', { enumerable: true, get() { return constants_1.BSON_BINARY_SUBTYPE_USER_DEFINED } }); Object.defineProperty(exports, 'BSON_BINARY_SUBTYPE_UUID', { enumerable: true, get() { return constants_1.BSON_BINARY_SUBTYPE_UUID } }); Object.defineProperty(exports, 'BSON_BINARY_SUBTYPE_UUID_NEW', { enumerable: true, get() { return constants_1.BSON_BINARY_SUBTYPE_UUID_NEW } }); Object.defineProperty(exports, 'BSON_DATA_ARRAY', { enumerable: true, get() { return constants_1.BSON_DATA_ARRAY } }); Object.defineProperty(exports, 'BSON_DATA_BINARY', { enumerable: true, get() { return constants_1.BSON_DATA_BINARY } }); Object.defineProperty(exports, 'BSON_DATA_BOOLEAN', { enumerable: true, get() { return constants_1.BSON_DATA_BOOLEAN } }); Object.defineProperty(exports, 'BSON_DATA_CODE', { enumerable: true, get() { return constants_1.BSON_DATA_CODE } }); Object.defineProperty(exports, 'BSON_DATA_CODE_W_SCOPE', { enumerable: true, get() { return constants_1.BSON_DATA_CODE_W_SCOPE } }); Object.defineProperty(exports, 'BSON_DATA_DATE', { enumerable: true, get() { return constants_1.BSON_DATA_DATE } }); Object.defineProperty(exports, 'BSON_DATA_DBPOINTER', { enumerable: true, get() { return constants_1.BSON_DATA_DBPOINTER } }); Object.defineProperty(exports, 'BSON_DATA_DECIMAL128', { enumerable: true, get() { return constants_1.BSON_DATA_DECIMAL128 } }); Object.defineProperty(exports, 'BSON_DATA_INT', { enumerable: true, get() { return constants_1.BSON_DATA_INT } }); Object.defineProperty(exports, 'BSON_DATA_LONG', { enumerable: true, get() { return constants_1.BSON_DATA_LONG } }); Object.defineProperty(exports, 'BSON_DATA_MAX_KEY', { enumerable: true, get() { return constants_1.BSON_DATA_MAX_KEY } }); Object.defineProperty(exports, 'BSON_DATA_MIN_KEY', { enumerable: true, get() { return constants_1.BSON_DATA_MIN_KEY } }); Object.defineProperty(exports, 'BSON_DATA_NULL', { enumerable: true, get() { return constants_1.BSON_DATA_NULL } }); Object.defineProperty(exports, 'BSON_DATA_NUMBER', { enumerable: true, get() { return constants_1.BSON_DATA_NUMBER } }); Object.defineProperty(exports, 'BSON_DATA_OBJECT', { enumerable: true, get() { return constants_1.BSON_DATA_OBJECT } }); Object.defineProperty(exports, 'BSON_DATA_OID', { enumerable: true, get() { return constants_1.BSON_DATA_OID } }); Object.defineProperty(exports, 'BSON_DATA_REGEXP', { enumerable: true, get() { return constants_1.BSON_DATA_REGEXP } }); Object.defineProperty(exports, 'BSON_DATA_STRING', { enumerable: true, get() { return constants_1.BSON_DATA_STRING } }); Object.defineProperty(exports, 'BSON_DATA_SYMBOL', { enumerable: true, get() { return constants_1.BSON_DATA_SYMBOL } }); Object.defineProperty(exports, 'BSON_DATA_TIMESTAMP', { enumerable: true, get() { return constants_1.BSON_DATA_TIMESTAMP } }); Object.defineProperty(exports, 'BSON_DATA_UNDEFINED', { enumerable: true, get() { return constants_1.BSON_DATA_UNDEFINED } }); Object.defineProperty(exports, 'BSON_INT32_MAX', { enumerable: true, get() { return constants_1.BSON_INT32_MAX } }); Object.defineProperty(exports, 'BSON_INT32_MIN', { enumerable: true, get() { return constants_1.BSON_INT32_MIN } }); Object.defineProperty(exports, 'BSON_INT64_MAX', { enumerable: true, get() { return constants_1.BSON_INT64_MAX } }); Object.defineProperty(exports, 'BSON_INT64_MIN', { enumerable: true, get() { return constants_1.BSON_INT64_MIN } }); let extended_json_2 = __nccwpck_require__(177); Object.defineProperty(exports, 'EJSON', { enumerable: true, get() { return extended_json_2.EJSON } }); let timestamp_2 = __nccwpck_require__(481); Object.defineProperty(exports, 'LongWithoutOverridesClass', { enumerable: true, get() { return timestamp_2.LongWithoutOverridesClass } }); let MAXSIZE = 1024 * 1024 * 17; let buffer = buffer_1.Buffer.alloc(MAXSIZE); function setInternalBufferSize(size) { if (buffer.length < size) { buffer = buffer_1.Buffer.alloc(size); } } exports.setInternalBufferSize = setInternalBufferSize; function serialize(object, options) { if (options === void 0) { options = {}; } let checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false; let serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false; let ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true; let minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE; if (buffer.length < minInternalBufferSize) { buffer = buffer_1.Buffer.alloc(minInternalBufferSize); } let serializationIndex = serializer_1.serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []); let finishedBuffer = buffer_1.Buffer.alloc(serializationIndex); buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length); return finishedBuffer; } exports.serialize = serialize; function serializeWithBufferAndIndex(object, finalBuffer, options) { if (options === void 0) { options = {}; } let checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false; let serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false; let ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true; let startIndex = typeof options.index === 'number' ? options.index : 0; let serializationIndex = serializer_1.serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined); buffer.copy(finalBuffer, startIndex, 0, serializationIndex); return startIndex + serializationIndex - 1; } exports.serializeWithBufferAndIndex = serializeWithBufferAndIndex; function deserialize(buffer, options) { if (options === void 0) { options = {}; } return deserializer_1.deserialize(ensure_buffer_1.ensureBuffer(buffer), options); } exports.deserialize = deserialize; function calculateObjectSize(object, options) { if (options === void 0) { options = {}; } options = options || {}; let serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false; let ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true; return calculate_size_1.calculateObjectSize(object, serializeFunctions, ignoreUndefined); } exports.calculateObjectSize = calculateObjectSize; function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) { let internalOptions = { allowObjectSmallerThanBufferSize: true, index: 0, ...options }; let bufferData = ensure_buffer_1.ensureBuffer(data); let index = startIndex; for (let i = 0; i < numberOfDocuments; i++) { let size = bufferData[index] | bufferData[index + 1] << 8 | bufferData[index + 2] << 16 | bufferData[index + 3] << 24; internalOptions.index = index; documents[docStartIndex + i] = deserializer_1.deserialize(bufferData, internalOptions); index += size } return index; } exports.deserializeStream = deserializeStream; let BSON = {
      Binary: binary_1.Binary, Code: code_1.Code, DBRef: db_ref_1.DBRef, Decimal128: decimal128_1.Decimal128, Double: double_1.Double, Int32: int_32_1.Int32, Long: long_1.Long, UUID: uuid_1.UUID, Map: map_1.Map, MaxKey: max_key_1.MaxKey, MinKey: min_key_1.MinKey, ObjectId: objectid_1.ObjectId, ObjectID: objectid_1.ObjectId, BSONRegExp: regexp_1.BSONRegExp, BSONSymbol: symbol_1.BSONSymbol, Timestamp: timestamp_1.Timestamp, EJSON: extended_json_1.EJSON, setInternalBufferSize, serialize, serializeWithBufferAndIndex, deserialize, calculateObjectSize, deserializeStream
    }; exports.default = BSON;
  })(); module.exports = __webpack_exports__;
})();
